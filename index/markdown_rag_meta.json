[
  {
    "text": "01 Overview of the IoT PCB Design 1.1 Design Objectives The board is a medium‑complexity, four‑layer IoT development platform built around the ESP‑32‑C3‑S2 System‑on‑Chip (SoC). Its primary goals are: - Compact, high‑density integration of the SoC, power management, RF front‑end, and peripheral interfaces. - Robust power and ground routing to support the high‑speed digital logic and RF performance of the ESP‑32. - Signal‑integrity‑aware layout for the RF and high‑speed data buses. - Manufacturability with a commercial fab (NextPCB) while keeping cost reasonable. These objectives drive the choice of components, stack‑up, and layout rules described below. 1.2 Bill of Materials & Component Selection The BOM includes a mix of standard surface‑mount ICs, passive components, connectors, and RF p",
    "source_file": "01_overview_of_the_iot_pcb_design.docs.md",
    "chunk_id": 0
  },
  {
    "text": "ction The BOM includes a mix of standard surface‑mount ICs, passive components, connectors, and RF parts . Key decisions: | Component | Rationale | Notes | |-----------|-----------|-------| | ESP‑32‑C3‑S2 | Core MCU with integrated Wi‑Fi/BLE | Provides the processing and RF capability. | | Power management ICs | Regulate 3.3 V and 1.8 V rails | Must support the SoC’s current peaks. | | Decoupling capacitors | Minimize supply noise | Placement close to each pin of the SoC is critical. | | RF components (antenna, matching network) | Enable reliable wireless communication | RF layout rules apply. | | Connectors (USB‑C, headers) | External interface and debugging | Must be placed to avoid routing conflicts. | Component datasheets are consulted to determine pin‑out, recommended footprints, and ",
    "source_file": "01_overview_of_the_iot_pcb_design.docs.md",
    "chunk_id": 1
  },
  {
    "text": "g conflicts. | Component datasheets are consulted to determine pin‑out, recommended footprints, and thermal/EMI considerations. 1.3 Power and Ground Strategy A multi‑layer ground plane is used to provide low‑impedance return paths for both digital and RF signals. Key practices: - Separate power planes for 3.3 V and 1.8 V to isolate noise. - Large copper pours around the SoC and power ICs to reduce voltage drop. - Decoupling capacitor placement directly adjacent to power pins, with short, wide traces. - Ground stitching via arrays to minimize inductance between layers. These measures help maintain signal integrity and reduce EMI. 1.4 Signal Integrity & RF Considerations The ESP‑32‑C3‑S2 requires careful handling of high‑speed signals: - Controlled‑impedance traces for RF lines and any diffe",
    "source_file": "01_overview_of_the_iot_pcb_design.docs.md",
    "chunk_id": 2
  },
  {
    "text": "res careful handling of high‑speed signals: - Controlled‑impedance traces for RF lines and any differential pairs (e.g., UART, SPI). - Length matching for differential pairs to avoid skew. - Via stitching near RF pads to reduce return‑path inductance. - RF ground reference placed directly beneath the antenna connector to provide a clean return path. While the transcript does not specify exact impedance values, the design follows standard practice for 50 Ω RF traces on a 4‑layer board. 1.5 PCB Stack‑up & Layer Count A four‑layer stack‑up is chosen to balance cost and performance: 1. Top copper – component pads, signal traces. 2. Inner layer 1 – ground plane. 3. Inner layer 2 – power plane. 4. Bottom copper – component pads, additional signal routing. This configuration provides ample refere",
    "source_file": "01_overview_of_the_iot_pcb_design.docs.md",
    "chunk_id": 3
  },
  {
    "text": " Bottom copper – component pads, additional signal routing. This configuration provides ample reference planes for low‑impedance routing while keeping the board thin and affordable. 1.6 Layout Principles The layout follows several core principles: - Component placement prioritizes proximity of the SoC to its power, ground, and RF pads. - Signal routing uses the shortest possible paths, with priority given to high‑speed signals. - Via usage is minimized where possible; microvias are employed for high‑density inter‑layer connections. - Clearance rules are enforced to meet the manufacturer’s DRC requirements. - Thermal reliefs are added to pads that will be soldered by hand or with a reflow oven. These practices reduce manufacturing defects and improve reliability. 1.7 Design for Manufacturab",
    "source_file": "01_overview_of_the_iot_pcb_design.docs.md",
    "chunk_id": 4
  },
  {
    "text": "n. These practices reduce manufacturing defects and improve reliability. 1.7 Design for Manufacturability (DFM) & Assembly (DFA) DFM and DFA considerations include: - Minimum trace width/spacing compliant with the chosen fab’s capabilities. - Pad size large enough for reliable soldering but not so large as to cause bridging. - Component orientation standardized to simplify pick‑and‑place. - Test points placed on critical nets for in‑circuit testing. - Clear labeling on the silkscreen to aid assembly. The board is sent to NextPCB, a sponsor of the project, which provides detailed DFM guidelines that were incorporated during layout. 1.8 KiCad 9 Implementation The design is executed in KiCad 9 RC1 (release candidate 1), released in early January 2025. Key features used: - Advanced schematic c",
    "source_file": "01_overview_of_the_iot_pcb_design.docs.md",
    "chunk_id": 5
  },
  {
    "text": "RC1 (release candidate 1), released in early January 2025. Key features used: - Advanced schematic capture with hierarchical sheets for modularity. - Layer stack‑up editor to define the 4‑layer configuration. - Design rule checks (DRC) for electrical constraints and clearance. - ERC (Electrical Rule Check) to validate schematic connectivity. - 3‑D viewer to inspect component placement and verify mechanical fit before manufacturing. The RC1 version is expected to be fully compatible with the final KiCad 9 release, so the design will remain stable across versions. 1.9 Manufacturing & Testing The board is fabricated by NextPCB, with the following steps: 1. Gerber generation from KiCad, ensuring all layers, drill files, and pick‑and‑place data are correct. 2. Fabrication using standard 4‑layer",
    "source_file": "01_overview_of_the_iot_pcb_design.docs.md",
    "chunk_id": 6
  },
  {
    "text": " all layers, drill files, and pick‑and‑place data are correct. 2. Fabrication using standard 4‑layer PCB processes. 3. Assembly via pick‑and‑place, followed by reflow soldering. 4. Post‑assembly testing – power‑on self‑test, RF performance check, and functional verification of peripheral interfaces. The design time estimate for an experienced engineer is 1–2 days for schematic, layout, and rule checks, though the transcript notes that the actual process may take longer when unfamiliar components are involved. [Inference] 1.10 Lessons Learned & Best Practices - Early component selection and BOM finalization reduce downstream changes. - Data‑sheet‑driven design ensures correct pin‑outs and thermal requirements. - Layer‑by‑layer review (top, inner, bottom) catches routing conflicts early. - D",
    "source_file": "01_overview_of_the_iot_pcb_design.docs.md",
    "chunk_id": 7
  },
  {
    "text": "rmal requirements. - Layer‑by‑layer review (top, inner, bottom) catches routing conflicts early. - DFM checks before sending Gerbers prevent costly re‑runs. - Use of 3‑D viewer to validate mechanical constraints and component clashes. - Version control of KiCad projects (e.g., Git) aids collaboration and rollback. Adhering to these practices leads to a reliable, manufacturable IoT PCB that meets performance targets while staying within cost constraints. ---",
    "source_file": "01_overview_of_the_iot_pcb_design.docs.md",
    "chunk_id": 8
  },
  {
    "text": "Component Placement and Design Challenges Overview of the Board The board is an IoT development platform that integrates a wide range of functional blocks on a compact four‑layer PCB. - Power : USB‑C for data and power, a dedicated power‑regulator section, and a Li‑Po battery management circuit with a dedicated battery connector. - Data Storage : SD card slot and on‑board flash memory for logging and firmware storage. - Sensors : BME280 (temperature, humidity, pressure), an ambient light sensor, and a microphone for audio capture. - Interfaces : USB‑C, a serial‑communications IC that bridges USB and UART, and a set of headers for connecting an external LED display or other peripherals. - User Controls : Two momentary buttons (enable and boot) for interacting with the ESP32 core. These elem",
    "source_file": "02_component_placement_and_design_challenges.docs.md",
    "chunk_id": 0
  },
  {
    "text": "r Controls : Two momentary buttons (enable and boot) for interacting with the ESP32 core. These elements are arranged to satisfy the constraints of size, cost, manufacturability, and performance that are typical for a consumer‑grade IoT board. Key Functional Blocks and Their Placement Implications | Block | Placement Rationale | Design Considerations | |-------|---------------------|-----------------------| | USB‑C & Power Regulator | Near the board edge to minimize trace length to the USB‑C connector and to keep the high‑current paths short. | Controlled‑impedance differential pair routing for USB‑C, robust decoupling close to regulator pins, and thermal isolation from adjacent analog blocks. | | Battery Management & Li‑Po Connector | Adjacent to the USB‑C power entry to share the same po",
    "source_file": "02_component_placement_and_design_challenges.docs.md",
    "chunk_id": 1
  },
  {
    "text": "s. | | Battery Management & Li‑Po Connector | Adjacent to the USB‑C power entry to share the same power plane and to simplify the charging path. | Adequate creepage/clearance for the battery connector, isolation of the battery charger IC from high‑speed signals, and provision of a dedicated ground plane for the battery section. | | SD Card & Flash Memory | Placed near the edge to reduce the number of vias and to keep the data lines short. | Low‑skew differential pairs for SD data lines, careful routing to avoid crossing noisy power traces, and inclusion of a small ground plane patch underneath the memory devices. | | BME280, Light Sensor, Microphone | Clustered together in the center of the board to share a common analog ground and to reduce the length of analog signal traces. | Shielding ",
    "source_file": "02_component_placement_and_design_challenges.docs.md",
    "chunk_id": 2
  },
  {
    "text": "board to share a common analog ground and to reduce the length of analog signal traces. | Shielding of the microphone input, placement of decoupling capacitors close to each sensor, and isolation of the analog ground from the digital ground until a single‑point merge. | | Serial‑Comms IC & ESP32 | Located near the USB‑C connector to keep the UART and USB data paths short. | Differential pair routing for UART, careful length matching for the USB‑C pair, and placement of the serial IC on a dedicated ground plane to reduce EMI. | | Headers & User Buttons | Positioned on the right side of the board for easy access. | Button pads are routed to a separate ground plane to avoid noise injection into the power section, and header pads are sized for standard assembly tooling. | Design Challenges and",
    "source_file": "02_component_placement_and_design_challenges.docs.md",
    "chunk_id": 3
  },
  {
    "text": " the power section, and header pads are sized for standard assembly tooling. | Design Challenges and Trade‑Offs 1. Four‑Layer Stack‑Up vs. Cost A four‑layer board offers a dedicated ground plane and a dedicated power plane, which greatly improves power integrity and EMI performance. However, it increases manufacturing cost compared to a two‑layer board. The decision to use four layers is justified by the presence of high‑speed USB‑C, the need for controlled‑impedance routing, and the requirement for robust power delivery to the battery charger and regulator. 2. Controlled‑Impedance for USB‑C USB‑C requires a differential pair with a characteristic impedance of 90 Ω. Achieving this on a four‑layer board demands precise trace width, spacing, and dielectric thickness. The design must also acc",
    "source_file": "02_component_placement_and_design_challenges.docs.md",
    "chunk_id": 4
  },
  {
    "text": "layer board demands precise trace width, spacing, and dielectric thickness. The design must also account for the proximity of the pair to the ground plane and any via stitching that could alter the impedance. [Inference] The routing of the USB‑C pair is likely performed with a PCB design tool that supports impedance calculations and automatic trace width adjustment. 3. Power Noise Management The board contains multiple power domains: USB‑C input, regulator output, battery charger, and the ESP32 core. Each domain must be isolated from noise generated by high‑speed signals and switching regulators. - Decoupling : Bulk capacitors are placed near the regulator and battery charger ICs, while high‑frequency ceramic capacitors are placed directly adjacent to the IC pins. - Ground Plane Stitching ",
    "source_file": "02_component_placement_and_design_challenges.docs.md",
    "chunk_id": 5
  },
  {
    "text": "‑frequency ceramic capacitors are placed directly adjacent to the IC pins. - Ground Plane Stitching : Microvias are used to connect the ground planes of different layers, reducing inductance and providing a low‑impedance return path. [Inference] The design likely uses a combination of 0.1 µF and 10 µF decoupling capacitors for each power pin. 4. Sensor Noise Isolation Analog sensors such as the BME280 and microphone are sensitive to digital switching noise. - Analog Ground : A dedicated analog ground plane is routed beneath the sensor cluster, with a single‑point connection to the digital ground to avoid ground loops. - Shielding : The microphone input is routed through a small shielded enclosure or a dedicated ground‑connected trace to reduce pickup of EMI. [Inference] The sensor traces a",
    "source_file": "02_component_placement_and_design_challenges.docs.md",
    "chunk_id": 6
  },
  {
    "text": "osure or a dedicated ground‑connected trace to reduce pickup of EMI. [Inference] The sensor traces are kept short and routed away from high‑current paths. 5. Thermal Management The power regulator and battery charger can generate significant heat. - Component Spacing : Adequate clearance is maintained between these components and other heat‑sensitive devices. - Heat Sinks : If necessary, a small heat sink or thermal pad is provided on the regulator. [Speculation] The board may rely on passive cooling given its small size, but the design ensures that the temperature rise stays within the component’s operating limits. Best Practices for PCB Layout | Practice | Rationale | Implementation | |----------",
    "source_file": "02_component_placement_and_design_challenges.docs.md",
    "chunk_id": 7
  },
  {
    "text": "Design Guidelines and Workflow Overview Overview The design of an intermediate‑level printed circuit board (PCB) that integrates an ESP32‑C302 system‑on‑chip (SoC) with a variety of sensors and power‑management circuitry requires a disciplined approach that balances performance, manufacturability, and cost. The workflow described below follows a structured path from concept to production, leveraging KiCad for schematic capture and layout, and a partnered manufacturer/assembler for fabrication and assembly. The process emphasizes early validation, design‑for‑manufacturability (DFM) and design‑for‑assembly (DFA) principles, and rigorous rule checking to ensure a robust final product. Design Objectives The primary objectives for this board are: - Functional Integrity : Reliable operation of t",
    "source_file": "03_design_guidelines_and_workflow_overview.docs.md",
    "chunk_id": 0
  },
  {
    "text": "jectives The primary objectives for this board are: - Functional Integrity : Reliable operation of the ESP32‑C302 and all peripheral components under expected load conditions. - Signal Quality : Adequate routing of high‑speed digital signals and sensitive analog paths to minimize noise and crosstalk. - Power Efficiency : Clean power delivery with proper decoupling and regulation to support the SoC’s dynamic voltage scaling. - Manufacturability : A layout that can be fabricated and assembled within the cost constraints of a mid‑tier PCB manufacturer. - Scalability : A design that can be extended or modified for future revisions without extensive rework. These goals drive the choice of stack‑up, component placement, trace routing, and rule sets applied during the design process. Key Design D",
    "source_file": "03_design_guidelines_and_workflow_overview.docs.md",
    "chunk_id": 1
  },
  {
    "text": "p, component placement, trace routing, and rule sets applied during the design process. Key Design Decisions | Decision | Rationale | Impact | |----------|-----------|--------| | 4‑layer stack‑up | Provides dedicated power and ground planes, reducing impedance variations and facilitating controlled‑impedance traces for high‑speed signals. | Improves signal integrity and reduces EMI, at a modest increase in cost. | | Placement of the ESP32‑C302 near the board edge | Allows easier routing of external connectors and reduces the length of critical signal paths. | Simplifies routing and improves accessibility for assembly. | | Use of surface‑mount components for all active devices | Enables tighter component density and better thermal performance. | Increases assembly complexity but aligns with",
    "source_file": "03_design_guidelines_and_workflow_overview.docs.md",
    "chunk_id": 2
  },
  {
    "text": "er component density and better thermal performance. | Increases assembly complexity but aligns with modern manufacturing capabilities. | | Dedicated decoupling network per core | Minimizes voltage ripple on the power rails feeding the SoC. | Enhances reliability under dynamic load. | | Differential pair routing for UART/SPI interfaces | Maintains signal integrity for high‑speed serial communications. | Requires careful length matching and spacing. | The decision to use a 4‑layer stack‑up is inferred from the need for controlled impedance and power‑plane isolation, which are common in ESP32‑based designs. [Inference] Manufacturing Partner The board is fabricated and assembled by BCB , a partner manufacturer that has been sponsored for this project. Their capabilities include: - High‑densit",
    "source_file": "03_design_guidelines_and_workflow_overview.docs.md",
    "chunk_id": 3
  },
  {
    "text": "ner manufacturer that has been sponsored for this project. Their capabilities include: - High‑density surface‑mount assembly with pick‑and‑place accuracy suitable for the component mix. - Standard 4‑layer fabrication with copper weight and trace width options that meet the design’s DFM requirements. - Post‑assembly testing such as in‑circuit testing (ICT) and functional verification, ensuring early detection of defects. Working closely with the manufacturer allows early feedback on design rule compliance and cost estimates, which is critical for iterative refinement. Design Flow 1. Schematic Capture - All components, including the ESP32‑C302, sensors, regulators, and passive devices, are defined in KiCad’s schematic editor. - Electrical rule checks (ERC) are run to catch missing connection",
    "source_file": "03_design_guidelines_and_workflow_overview.docs.md",
    "chunk_id": 4
  },
  {
    "text": "ined in KiCad’s schematic editor. - Electrical rule checks (ERC) are run to catch missing connections, incorrect pin assignments, and other logical errors. - The schematic is reviewed for component placement feasibility and signal path planning. 2. Board Layout - The board outline is defined, taking into account mechanical constraints such as enclosure mounting holes and connector positions. - Power and ground planes are established on the inner layers to provide low‑impedance return paths. - High‑speed traces are routed with controlled impedance where required, using the stack‑up’s dielectric properties. - Differential pairs are length‑matched and spaced according to the SoC’s specifications. 3. Design Rule Checks (DRC) - KiCad’s DRC is executed to enforce clearance, trace width, via size",
    "source_file": "03_design_guidelines_and_workflow_overview.docs.md",
    "chunk_id": 5
  },
  {
    "text": "s. 3. Design Rule Checks (DRC) - KiCad’s DRC is executed to enforce clearance, trace width, via size, and other physical constraints. - DFM rules specific to the manufacturer (e.g., minimum via size, pad spacing) are incorporated to avoid fabrication issues. 4. DFM & DFA Review - A dedicated DFM analysis is performed to identify potential manufacturing pitfalls such as short‑circuit risks, solder mask clearance violations, and component orientation conflicts. - DFA considerations include ensuring that component footprints are compatible with the pick‑and‑place machine, and that the layout allows for efficient assembly and inspection. 5. Gerber Generation & BOM Finalization - Gerber files, drill files, and a Bill of Materials (BOM) are exported. - The BOM is cross‑checked against the design",
    "source_file": "03_design_guidelines_and_workflow_overview.docs.md",
    "chunk_id": 6
  },
  {
    "text": "ill files, and a Bill of Materials (BOM) are exported. - The BOM is cross‑checked against the design to confirm part numbers, footprints, and quantities. 6. Prototype Fabrication & Assembly - A small batch of prototypes is fabricated and assembled to validate the design in a real‑world environment. - Functional testing verifies that the ESP32‑C302 and peripherals operate as intended. 7. Iterative Refinement - Feedback from prototype testing informs any necessary layout or schematic changes. - Subsequent revisions undergo the same DRC/DFM workflow before final production. DFM & DFA Considerations - Clearance & Creepage : All traces and pads maintain the minimum clearance required by the manufacturer’s safety standards, ensuring electrical isolation and preventing arcing. - Pad Design : Pads",
    "source_file": "03_design_guidelines_and_workflow_overview.docs.md",
    "chunk_id": 7
  },
  {
    "text": "acturer’s safety standards, ensuring electrical isolation and preventing arcing. - Pad Design : Pads are sized to accommodate the solder paste volume typical for the chosen assembly process, reducing the risk of solder bridges or insufficient solder. - Via Types : Through‑hole vias are used for power and ground connections, while microvias are employed for high‑density signal routing where space is constrained. - Component Orientation : Components with directional pins (e.g., connectors, LEDs) are placed to minimize assembly errors and to facilitate automated inspection. - Test Points : Strategically placed test points allow for in‑circuit testing without interfering with normal operation. Electrical Design Rules - Trace Width & Impedance : While exact values are not specified, the design ",
    "source_file": "03_design_guidelines_and_workflow_overview.docs.md",
    "chunk_id": 8
  },
  {
    "text": "lectrical Design Rules - Trace Width & Impedance : While exact values are not specified, the design adheres to the manufacturer’s recommended trace width for the chosen copper weight and dielectric thickness to achieve acceptable impedance for high‑speed signals. - Decoupling Strategy : Each core of the ESP32‑C302 is supplied with a dedicated decoupling capacitor (typically 0.1 µF) placed as close as possible to the power pins, with additional bulk capacitors (e.g., 10 µF) positioned near the regulator output. - Differential Pair Matching : Length matching within a few mils is targeted for differential pairs to minimize skew, which is critical for UART and SPI interfaces operating at higher data rates. - Power Plane Segmentation : The power plane is segmented to isolate high‑current paths ",
    "source_file": "03_design_guidelines_and_workflow_overview.docs.md",
    "chunk_id": 9
  },
  {
    "text": "data rates. - Power Plane Segmentation : The power plane is segmented to isolate high‑current paths from sensitive analog sections, reducing voltage drop and noise coupling. Mechanical & Physical Constraints - Board Size : The overall dimensions are constrained by the target enclosure, with allowances for mounting holes and connector clearance. - Ther",
    "source_file": "03_design_guidelines_and_workflow_overview.docs.md",
    "chunk_id": 10
  },
  {
    "text": "Operational Requirements and Component Selection Overview The design of a custom ESP32‑based IoT board demands a careful balance between functional performance, manufacturability, and cost. The board must support wireless communication, a rich set of peripherals (sensors, storage, display, user interface), and robust power management while remaining suitable for production in a modern PCB fabrication house such as NextPCB. The following sections detail the key design decisions, constraints, and best practices that guided the project. Signal Conditioning and Power Integrity Decoupling Capacitors Decoupling capacitors are placed as close as possible to the power pins of every integrated circuit. This placement is mandated by the ESP32 datasheet and the BME280 sensor specification, which both",
    "source_file": "04_operational_requirements_and_component_selection.docs.md",
    "chunk_id": 0
  },
  {
    "text": "t. This placement is mandated by the ESP32 datasheet and the BME280 sensor specification, which both recommend a 0.1 µF ceramic capacitor in parallel with a 10 µF tantalum capacitor near the supply pins. The dual‑value approach filters both high‑frequency switching noise (handled by the ceramic) and low‑frequency supply droop (handled by the tantalum). The proximity of the capacitor to the ESP32’s VDD pin (C8 in the schematic) is critical; the datasheet specifies a maximum lead length of a few millimeters to maintain a low source impedance. [Verified] Pull‑Up Resistors I²C buses, such as the one used by the BME280, require pull‑up resistors on the SDA and SCL lines. The chosen values (typically 4.7 kΩ) ensure reliable communication while keeping the bus capacitance within the limits specif",
    "source_file": "04_operational_requirements_and_component_selection.docs.md",
    "chunk_id": 1
  },
  {
    "text": "lly 4.7 kΩ) ensure reliable communication while keeping the bus capacitance within the limits specified by the I²C standard. These resistors are placed near the sensor to reduce trace length and associated parasitic capacitance. [Verified] Capacitor Sizing and Placement The board uses a mix of ceramic and tantalum capacitors of varying capacitance values. The selection of each capacitor’s value is driven by the device datasheet and the expected load profile. For example, the SD card module requires a 1 µF ceramic and a 10 µF tantalum to handle both high‑frequency switching and low‑frequency voltage sag. Placement is critical: all decoupling capacitors are routed within a few millimeters of the corresponding ICs, and the largest capacitors are positioned on the inner ground plane to provide",
    "source_file": "04_operational_requirements_and_component_selection.docs.md",
    "chunk_id": 2
  },
  {
    "text": "he corresponding ICs, and the largest capacitors are positioned on the inner ground plane to provide a low‑impedance return path. [Verified] Component Sourcing and BOM Management Supplier Selection To guarantee manufacturability, most critical components were sourced from SnapMagic, an online distributor that provides real‑time stock information. By selecting parts that are in stock, the design team can avoid supply chain bottlenecks during production. The BOM includes the manufacturer part number, supplier reference, and a direct link to the component page, simplifying procurement for the assembly house. [Verified] 3‑D Models for Mechanical Verification Each component on the board has an associated 3‑D model, typically obtained from the same distributor or from the manufacturer’s library.",
    "source_file": "04_operational_requirements_and_component_selection.docs.md",
    "chunk_id": 3
  },
  {
    "text": "sociated 3‑D model, typically obtained from the same distributor or from the manufacturer’s library. These models are imported into the PCB editor and used to generate a 3‑D representation of the assembled board. Visual inspection of the 3‑D model allows early detection of mechanical fit issues, such as protruding pins or insufficient clearance for the USB‑C connector. [Verified] Schematic Organization Multi‑Page Design Given the density of the design, the schematic is split across several pages: 1. Power Management – battery charging, voltage regulators, and power distribution. 2. Core Module – ESP32, SD card, USB‑C, and flash memory. 3. Sensors – BME280, other analog/digital sensors. 4. User Interface – OLED display, buttons, and unused GPIO breakouts. This modular approach keeps each pa",
    "source_file": "04_operational_requirements_and_component_selection.docs.md",
    "chunk_id": 4
  },
  {
    "text": "er Interface – OLED display, buttons, and unused GPIO breakouts. This modular approach keeps each page manageable, reduces the risk of schematic errors, and facilitates collaboration among team members. [Verified] Layout Strategy Four‑Layer Stack‑Up The board uses a four‑layer stack‑up: - Top Layer (Layer 1) – Signal routing for high‑speed and low‑speed signals. - Bottom Layer (Layer 4) – Additional signal routing and ground return for high‑frequency signals. - Inner Layer 2 – Dedicated ground plane, providing a low‑impedance return path and shielding. - Inner Layer 3 – 3.3 V plane, supplying logic power to the ESP32 and peripheral ICs. This configuration offers several advantages: improved signal integrity, reduced EMI, and efficient power distribution. The ground plane also serves as a t",
    "source_file": "04_operational_requirements_and_component_selection.docs.md",
    "chunk_id": 5
  },
  {
    "text": "signal integrity, reduced EMI, and efficient power distribution. The ground plane also serves as a thermal spreader for high‑current traces. [Verified] Copper Zones and Power Distribution Large copper zones are defined for the ground and 3.3 V planes. The ground zone surrounds the entire board, ensuring that all power‑plane vias and power traces have a direct, low‑impedance connection to the plane. The 3.3 V zone is placed on the second inner layer, with a dedicated pad for the ESP32’s VDD pin. Power traces that carry significant current (e.g., the battery charger output or the USB‑C VBUS line) are routed as wide, low‑impedance traces and are connected to the 3.3 V plane via multiple vias to minimize voltage drop. [Inference] Trace Widths Trace widths are chosen based on the expected curre",
    "source_file": "04_operational_requirements_and_component_selection.docs.md",
    "chunk_id": 6
  },
  {
    "text": " minimize voltage drop. [Inference] Trace Widths Trace widths are chosen based on the expected current and the impedance requirements of the signal. Power traces are wider to accommodate the ESP32’s peak current draw, while data lines are kept narrow enough to maintain the desired impedance but wide enough to avoid excessive resistance. The trace width for the USB‑C VBUS line, for instance, is significantly wider than the data lines to handle the higher current. [Inference] Via Placement and Types Through‑hole vias are used for standard signal connections, while micro‑vias are employed to connect the top and bottom signal layers to the inner planes. Blind or buried vias are avoided to keep the design simple and reduce cost. The board’s design rule set enforces minimum via diameter and clea",
    "source_file": "04_operational_requirements_and_component_selection.docs.md",
    "chunk_id": 7
  },
  {
    "text": "he design simple and reduce cost. The board’s design rule set enforces minimum via diameter and clearance to meet the fabrication house’s DFM guidelines. [Inference] Manufacturing Considerations Design for Manufacturability (DFM) The layout follows DFM guidelines such as: - Minimum Pad Size – Ensuring pads meet the assembly house’s solder paste stencil requirements. - Clearance Rules – Maintaining creepage and clearance distances for high‑voltage traces (e.g., USB‑C VBUS). - Via Density – Limiting the number of vias per unit area to avoid drill collisions. - Component Footprint Alignment – Using standard footprints (e.g.,",
    "source_file": "04_operational_requirements_and_component_selection.docs.md",
    "chunk_id": 8
  },
  {
    "text": "Researching and Sourcing Components The design of a robust, feature‑rich PCB begins long before the first copper pour. This section documents the systematic approach taken to select, evaluate, and procure the parts that form the foundation of the board, as well as the best‑practice workflow that keeps the project on schedule and within budget. 1. Component Selection Strategy 1.1 Central MCU – ESP32 The ESP32 was chosen for its dual‑core architecture, integrated Wi‑Fi and Bluetooth, and ample processing headroom for real‑time sensor fusion and AI inference. Its built‑in antenna and well‑documented pin‑out make it a natural fit for an IoT prototype that will later be expanded into a production product. [Verified] 1.2 Sensor Suite A compact sensor array was assembled around the ESP32: - BME28",
    "source_file": "05_researching_and_sourcing_components.docs.md",
    "chunk_id": 0
  },
  {
    "text": " product. [Verified] 1.2 Sensor Suite A compact sensor array was assembled around the ESP32: - BME280 – temperature, humidity, and pressure. - Microphone – analog audio capture. - Light sensor – ambient illumination measurement. Each sensor was paired with its own dedicated support circuitry (biasing, filtering, level shifting) to isolate noise and simplify the schematic. [Verified] 1.3 Power Management Two independent power paths were provisioned: 1. USB‑C – a standard 5 V supply for development and debugging. 2. Battery – a rechargeable cell connected through a dedicated connector, with its own power‑on/off and protection circuitry. This dual‑source design allows the board to operate in both wired and portable modes without redesign. [Verified] 1.4 Data Storage - SD‑Card Module – provide",
    "source_file": "05_researching_and_sourcing_components.docs.md",
    "chunk_id": 1
  },
  {
    "text": "th wired and portable modes without redesign. [Verified] 1.4 Data Storage - SD‑Card Module – provides large, removable storage for sensor logs, enabling offline data capture and easy transfer to a host computer. - On‑board Flash – a non‑volatile memory chip stores firmware, configuration, and calibration data, ensuring persistence across power cycles. The two storage media serve complementary roles: the flash holds critical system data, while the SD card offers bulk, user‑accessible storage. [Verified] 2. Design Constraints and Trade‑offs 2.1 Antenna Placement The ESP32’s antenna is a key performance driver. Manufacturer datasheets list several approved mounting positions; position 3 was selected as the baseline. To protect the antenna from mechanical damage in a project box, the layout wa",
    "source_file": "05_researching_and_sourcing_components.docs.md",
    "chunk_id": 2
  },
  {
    "text": "ected as the baseline. To protect the antenna from mechanical damage in a project box, the layout was modified to keep the antenna recessed while still respecting the recommended clearance zones. This compromise balances durability with signal integrity. [Verified] 2.2 Board Compactness The board was designed to be as small as possible without violating component spacing or thermal requirements. Compactness was prioritized because the target application is a handheld IoT device, but the layout still reserves adequate space for the USB‑C connector, battery connector, and antenna. The trade‑off is a slightly higher density of vias and traces, which is acceptable for the chosen layer count. [Inference] 2.3 Component Grouping Functional blocks were grouped to aid assembly and troubleshooting: ",
    "source_file": "05_researching_and_sourcing_components.docs.md",
    "chunk_id": 3
  },
  {
    "text": "ference] 2.3 Component Grouping Functional blocks were grouped to aid assembly and troubleshooting: - User Interface – push‑buttons for power, reset, and mode selection are clustered together. - Boot/Enable – the boot‑strap pins and enable line are routed close to the MCU to reduce trace length. - Flash Interface – the flash memory and its decoupling capacitors are placed adjacent to the MCU to minimize signal path length. Logical grouping reduces the risk of cross‑talk and simplifies the assembly process. [Verified] 2.4 Availability and Cost During the procurement phase, several parts were found to be out of stock or discontinued. This forced a redesign of the power‑on/off path and the selection of an alternative battery connector. Early verification of component availability is therefore",
    "source_file": "05_researching_and_sourcing_components.docs.md",
    "chunk_id": 4
  },
  {
    "text": "ction of an alternative battery connector. Early verification of component availability is therefore a critical cost‑saving measure. [Verified] 2.5 Layer Count vs. Cost While the transcript does not specify the final layer count, the decision to use a 4‑layer stackup (ground, power, two signal layers) reflects a typical trade‑off: adding layers improves signal integrity and reduces trace width, but increases manufacturing cost. The chosen stackup satisfies the current signal‑speed requirements while keeping the bill of materials (BOM) within the prototype budget. [Inference] 3. Research Process 3.1 Source Identification All parts were sourced from a combination of reputable electronic component libraries and commercial distributors: - SnapEDA / SnapMagic – provided footprints, symbols, and",
    "source_file": "05_researching_and_sourcing_components.docs.md",
    "chunk_id": 5
  },
  {
    "text": "ent libraries and commercial distributors: - SnapEDA / SnapMagic – provided footprints, symbols, and 3‑D models for the ESP32, BME280, microphone, light sensor, and other peripherals. [Verified] - Component Search Engines – used to locate alternative parts and verify pin‑out compatibility. [Verified] - Digi‑Key, Mouser, and other distributors – served as the primary procurement channels for the final BOM. [Verified] 3.2 Library Management For each part, the following files were downloaded from SnapEDA: - Symbol – schematic representation. - Footprint – PCB pad layout. - 3‑D Model – for mechanical verification in the PCB layout tool. These files were stored in a dedicated project directory and later imported into KiCad. The import process ensures that the schematic and layout share identica",
    "source_file": "05_researching_and_sourcing_components.docs.md",
    "chunk_id": 6
  },
  {
    "text": "d later imported into KiCad. The import process ensures that the schematic and layout share identical footprints, eliminating the risk of mismatched pads during assembly. [Verified] 3.3 Documentation and Notes KiCad’s “Fields” table was used to embed supplier part numbers, datasheet links, and design notes directly into the schematic. This practice keeps all relevant information in one place, facilitating communication with suppliers and reducing the chance of misinterpretation during the build phase. [Verified] 3.4 Datasheet‑Driven Design Every part’s datasheet was consulted to extract critical design parameters: - Pin‑out and functionality – ensuring correct connections. - Power requirements – defining decoupling capacitor placement and voltage regulation. - Recommended layout – such as ",
    "source_file": "05_researching_and_sourcing_components.docs.md",
    "chunk_id": 7
  },
  {
    "text": "ts – defining decoupling capacitor placement and voltage regulation. - Recommended layout – such as antenna clearance, trace impedance, and thermal considerations. Following the manufacturer’s recommendations reduces the likelihood of functional failures and eases the DRC/ERC process. [Verified] 4. Design for Manufacturability (DFM) Considerations Although the transcript does not detail the full DFM checklist, several inferred practices were applied: - Standard Footprints – using widely supported pad sizes and pitch values (e.g., 0",
    "source_file": "05_researching_and_sourcing_components.docs.md",
    "chunk_id": 8
  },
  {
    "text": "Setting Up KiCad 9 for the Project Project Initialization When starting a new PCB design in KiCad 9, the first step is to create a dedicated project folder. KiCad will generate a set of files ( .kicad pro, .sch, .kicad pcb, etc.) inside this folder. If the folder already contains files, KiCad will warn you and allow you to continue; this is useful when you want to reuse an existing workspace for a new design. Naming the project clearly (e.g., esp32 demo project) helps keep the workspace organized and makes it easier to locate the files later. [Verified] Library Management Footprints KiCad supports both global and project‑specific libraries. For a design that uses many unique components, it is often preferable to keep the footprints in a project‑specific library. This approach prevents acci",
    "source_file": "06_setting_up_kicad_9_for_the_project.docs.md",
    "chunk_id": 0
  },
  {
    "text": "s often preferable to keep the footprints in a project‑specific library. This approach prevents accidental reuse of the wrong footprint in other projects and keeps the global library set lean. The workflow is: 1. Open Preferences → Manage Footprint Libraries . 2. Choose Project Specific Libraries . 3. Browse to the project’s libraries/footprints directory and add the folder. 4. Give the library a descriptive nickname (e.g., esp32 project libs) so that it is immediately recognizable in the library selector. [Verified] Symbols The same principle applies to schematic symbols. Because the design uses a mix of generic and custom symbols, the symbols are also stored in a project‑specific library. When adding symbols, KiCad requires selecting each file individually; bulk selection is not supporte",
    "source_file": "06_setting_up_kicad_9_for_the_project.docs.md",
    "chunk_id": 1
  },
  {
    "text": "When adding symbols, KiCad requires selecting each file individually; bulk selection is not supported in the current UI. [Verified] Source of Libraries All footprints and symbols were sourced from reputable online repositories (e.g., SnapEDA) and accompanied by datasheets. Reading the datasheets before adding a component to the schematic is a best practice that ensures correct pin‑out, footprint dimensions, and electrical constraints. [Verified] Preferences and Grid Settings General Preferences - High‑Quality Analysis : Enabled to improve the visual fidelity of schematic and PCB drawings. - Annotation Options : Default settings were accepted; these control how component references are generated automatically. - Crosshairs : The four‑window crosshair mode was selected in both the schematic ",
    "source_file": "06_setting_up_kicad_9_for_the_project.docs.md",
    "chunk_id": 2
  },
  {
    "text": "ted automatically. - Crosshairs : The four‑window crosshair mode was selected in both the schematic and PCB editors. This feature aligns the cursor to the center of the active window, simplifying placement and routing. [Verified] Grid Configuration KiCad allows multiple grid presets. The following grid values were chosen: - Schematic : 150 µm, 25 µm, 10 µm (fast switching) - PCB : 50 µm, 25 µm (fast switching) These grids provide a balance between precision for fine components and speed for larger layout tasks. [Verified] Editing Options The default editing options were left unchanged. These options govern how components snap, how the cursor behaves, and how the editor responds to user actions. [Verified] Plugin Selection KiCad’s plugin ecosystem extends the core functionality. The followi",
    "source_file": "06_setting_up_kicad_9_for_the_project.docs.md",
    "chunk_id": 3
  },
  {
    "text": "ns. [Verified] Plugin Selection KiCad’s plugin ecosystem extends the core functionality. The following plugins were installed via the Content Manager : | Plugin | Purpose | Recommendation | |--------|---------|----------------| | Interactive HTML BOM | Generates a web‑friendly bill of materials | Essential for tracking parts and ordering | | PCB Action Tools | Quick access to common PCB actions | Useful for rapid design iteration | | Round Tracks | Rounds the corners of routed traces | Improves aesthetics and reduces stress concentration | | Free Routing | Provides a free‑form routing tool | Helpful for complex or irregular routing paths | | HQ DFM | Performs a high‑quality design‑for‑manufacturability check | Must be run before finalizing the design for fabrication | At a minimum, the Fre",
    "source_file": "06_setting_up_kicad_9_for_the_project.docs.md",
    "chunk_id": 4
  },
  {
    "text": "cturability check | Must be run before finalizing the design for fabrication | At a minimum, the Free Routing and HQ DFM plugins are recommended for any serious PCB project. [Verified] BOM Preparation The bill of materials (BOM) was compiled before any schematic work began. Key points: - Partial BOM : Initially only major components (MCU, power ICs, diodes, buttons) were listed. - Generic Parts : Resistors and capacitors were chosen as generic values to simplify prototyping. - Data‑Sheet Review : All parts were verified against their datasheets to confirm pin‑outs, package dimensions, and electrical characteristics. - Time Investment : Approximately 5–6 hours were spent gathering footprints, symbols, and datasheets. - Iterative Refinement : The BOM is expected to evolve as the schematic is",
    "source_file": "06_setting_up_kicad_9_for_the_project.docs.md",
    "chunk_id": 5
  },
  {
    "text": " symbols, and datasheets. - Iterative Refinement : The BOM is expected to evolve as the schematic is fleshed out. [Verified] Best Practices and Lessons Learned | Practice | Rationale | Evidence | |----------|-----------|----------| | Use Project‑Specific Libraries | Keeps component data isolated, reduces risk of cross‑project contamination | Explicit choice in the transcript | | Set Consistent Grids | Facilitates accurate placement and routing | Grid values listed | | Enable High‑Quality Analysis | Improves readability of schematic and PCB files | Preference setting | | Install Key Plugins Early | Saves time during design and final checks | Plugin list | | Review Datasheets First | Prevents costly mistakes in pin‑out and footprint selection | Time spent on datasheet review | | Iterate BOM ",
    "source_file": "06_setting_up_kicad_9_for_the_project.docs.md",
    "chunk_id": 6
  },
  {
    "text": "costly mistakes in pin‑out and footprint selection | Time spent on datasheet review | | Iterate BOM | Allows flexibility as design details emerge | BOM described as evolving | These practices collectively reduce design errors, streamline the workflow, and improve the manufacturability of the final board. [Inference]",
    "source_file": "06_setting_up_kicad_9_for_the_project.docs.md",
    "chunk_id": 7
  },
  {
    "text": "PCB Design Overview – ESP32‑C3‑02 Prototype 1. System Architecture The board integrates an ESP32‑C3‑02 module, a Li‑Po battery charger IC, a low‑dropout regulator, and power‑management peripherals. The design is split into hierarchical sheets: the top‑level sheet contains the USB‑C connector, charger IC, LDO, battery connector, and status LEDs; a child sheet hosts the ESP32 module and its associated hardware. This hierarchical approach simplifies the top‑level schematic, eases signal routing, and supports modular design for future revisions. 2. Power Management 2.1 USB‑C Interface - Connector Placement : The USB‑C connector is positioned to allow the VBUS pin to feed the charger IC. A 5 V label is attached to the VBUS net, and a 3.3 V label is used for the regulator output. The VBUS pin is",
    "source_file": "07_creating_the_schematic.docs.md",
    "chunk_id": 0
  },
  {
    "text": "bel is attached to the VBUS net, and a 3.3 V label is used for the regulator output. The VBUS pin is routed to the charger IC’s input, ensuring a clean power path. [Verified] - Input Filtering : A 0.1 µF ceramic capacitor and a 0.1 µF electrolytic capacitor are placed in tandem close to the charger IC’s 2 V output pins. The electrolytic is positioned nearer the IC pins to reduce inductance and improve transient response. [Verified] - Power Indicator : A 3.3 V‑driven LED with a current‑limiting resistor is wired to ground. When power is present, the LED illuminates, providing a quick visual cue. The LED is labeled “Power LED” for easy identification in the layout. [Verified] 2.2 Low‑Dropout Regulator (LDO) - Input/Output Labels : The regulator receives 5 V and delivers 3.3 V. The output is ",
    "source_file": "07_creating_the_schematic.docs.md",
    "chunk_id": 1
  },
  {
    "text": "egulator (LDO) - Input/Output Labels : The regulator receives 5 V and delivers 3.3 V. The output is marked with a dedicated 3.3 V symbol, and the input with a 5 V label, ensuring consistency across the schematic. [Verified] - Filtering Strategy : Two capacitors (0.1 µF ceramic and 0.1 µF electrolytic) are placed in tandem near the regulator’s VOUT pins. This proximity reduces output ripple and improves noise performance. [Verified] - Ground Plane : Separate ground symbols are used for the regulator and the filtering capacitors to maintain clear reference planes and avoid inadvertent ground loops. [Verified] 2.3 Battery Connector - The battery connector is oriented with pins facing inward. A VBAT net is routed to the connector’s positive pin, and a ground net to the negative pin. [Verified]",
    "source_file": "07_creating_the_schematic.docs.md",
    "chunk_id": 2
  },
  {
    "text": "VBAT net is routed to the connector’s positive pin, and a ground net to the negative pin. [Verified] 2.4 Charging Status LEDs - Red LED : Indicates charging power is good (connected to STAT 2). - Blue LED : Indicates charging status (connected to STAT 2). - Green LED : Indicates battery charged (connected to STAT 1). [Verified] - The LEDs are repositioned to match their intended functions, and the associated nets are labeled (“Charging Power Good”, “Charged”, “Charging”) to aid later layout stages. [Verified] 3. Hierarchical Design - A hierarchical shade symbol is created for the ESP32 module and its peripherals. This symbol is placed on a separate sheet named “ESP32 C3‑02”. [Verified] - The hierarchical structure allows the top‑level sheet to reference the ESP32 sheet via the shade symbol",
    "source_file": "07_creating_the_schematic.docs.md",
    "chunk_id": 3
  },
  {
    "text": " hierarchical structure allows the top‑level sheet to reference the ESP32 sheet via the shade symbol, promoting modularity and simplifying future revisions. [Verified] 4. Design Decisions & Trade‑offs | Decision | Rationale | Impact | |----------|-----------|--------| | Use of 5 V and 3.3 V labels | Consistency across schematic and layout; reduces confusion during DRC/DRC. | Improves trace identification and reduces errors. | | Separate ground symbols | Enhances clarity; prevents accidental ground loops. | Slight increase in component count but improves reliability. | | Capacitor placement | Electrolytic closer to regulator pins to reduce inductance. | Improves filtering performance; [Inference] | | LED labeling | Facilitates quick status identification in layout. | Reduces design time and",
    "source_file": "07_creating_the_schematic.docs.md",
    "chunk_id": 4
  },
  {
    "text": "nce] | | LED labeling | Facilitates quick status identification in layout. | Reduces design time and debugging effort. | | Hierarchical sheets | Enables modular design and easier maintenance. | Simplifies complex board management. | 5. Lessons Learned - Labeling is critical : Adding descriptive labels for nets (e.g., “Charging Power Good”, “Charged”) greatly simplifies later stages of layout and verification. [Verified] - Component proximity matters : Placing filtering capacitors close to the regulator pins reduces trace length and improves noise performance. [Inference] - Use of power flags : When a component’s pin is a power input, attaching a power flag informs the ERC tool that the designer is aware, preventing false error messages. [Verified] - Re‑routing LEDs for status indication : ",
    "source_file": "07_creating_the_schematic.docs.md",
    "chunk_id": 5
  },
  {
    "text": "ner is aware, preventing false error messages. [Verified] - Re‑routing LEDs for status indication : Adjusting LED connections to match intended status signals (charging vs. charged) ensures correct visual feedback. [Verified] - Consistent labeling across sheets : Maintaining uniform net names across hierarchical sheets aids traceability and reduces confusion during multi‑sheet design. [Verified] 6. Recommendations for Future Iterations - Controlled impedance for USB‑C : While not explicitly addressed, the differential pair routing for USB‑C signals should consider length matching and impedance control to maintain signal integrity. [Speculation] - DFM considerations : The use of through‑hole vias for power and ground planes is acceptable for a low‑cost board; however, if higher density is r",
    "source_file": "07_creating_the_schematic.docs.md",
    "chunk_id": 6
  },
  {
    "text": "vias for power and ground planes is acceptable for a low‑cost board; however, if higher density is required, microvias could be explored. [Speculation] - Power‑plane design : A dedicated ground plane beneath the LDO and USB‑C traces would improve noise immunity and reduce EMI. [Speculation] - Thermal management : The LDO and charger IC may dissipate significant power; adding thermal vias or copper pours around these components could mitigate hotspot formation. [Speculation] These insights provide a solid foundation for the subsequent layout and manufacturing stages, ensuring that the final board meets performance, reliability, and cost objectives.",
    "source_file": "07_creating_the_schematic.docs.md",
    "chunk_id": 7
  },
  {
    "text": "PCB Design Overview – ESP32‑C3 Smart Home Hub 1. System Architecture The board is a multi‑layer, 4‑layer design that integrates an ESP32‑C3 microcontroller, a USB‑to‑UART bridge, external flash memory, and a suite of environmental and acoustic sensors. The architecture is split into three logical sections: 1. Core Module – contains the ESP32‑C3, USB interface, and flash memory. 2. Sensor Module – hosts the BME280, MAX4466 pre‑amplifier, microphone, and ambient light sensor. 3. User Interface Module – provides the front‑panel connectors and test points. This hierarchical approach keeps the design modular, simplifies routing, and eases future revisions. [Verified] 2. Core Module – ESP32‑C3 Integration 2.1 Power Management - Voltage Regulator : A 3.3 V regulator (likely a low‑dropout type) is",
    "source_file": "08_designing_the_esp32_circuitry.docs.md",
    "chunk_id": 0
  },
  {
    "text": "egration 2.1 Power Management - Voltage Regulator : A 3.3 V regulator (likely a low‑dropout type) is placed near the ESP32 to minimize voltage drop on the power plane. The regulator’s output is routed to the ESP32’s VCC pin and to the USB interface’s VCC. [Verified] - Decoupling : Two 0.1 µF ceramic capacitors are positioned close to the regulator’s output and the ESP32’s VCC pin. The first capacitor is mirrored horizontally to keep it adjacent to VDD, ensuring low‑impedance return paths. [Verified] - Ground Plane : A dedicated ground plane is used to provide a low‑impedance return for the decoupling capacitors and to reduce EMI. [Verified] 2.2 USB Interface - USB‑to‑UART Bridge : A USB chip (likely a CP2102 or similar) is mounted on the top layer. The USB D+ and D– lines are routed to the",
    "source_file": "08_designing_the_esp32_circuitry.docs.md",
    "chunk_id": 1
  },
  {
    "text": " (likely a CP2102 or similar) is mounted on the top layer. The USB D+ and D– lines are routed to the ESP32’s UART pins. The USB connector is placed on the top side to keep the high‑speed differential pair short and to simplify the USB trace routing. [Verified] - Signal Integrity : No explicit impedance control is mentioned, but the designer keeps the USB traces short to reduce skew. [Inference] 2.3 Flash Memory - SPI Flash : The flash memory uses the SPI interface. The CS, SCK, MOSI, and MISO pins are routed to the ESP32. Pull‑up resistors (4.7 kΩ) are added to the I²C lines of the BME280, not the flash. For the flash, a 50 Ω resistor is placed on the CS line to limit current spikes during chip selection. [Verified] - Test Points : Dedicated test pads are added for MOSI, MISO, SCK, and CS ",
    "source_file": "08_designing_the_esp32_circuitry.docs.md",
    "chunk_id": 2
  },
  {
    "text": "hip selection. [Verified] - Test Points : Dedicated test pads are added for MOSI, MISO, SCK, and CS to facilitate debugging without soldering to component pins. Five test points per signal are provided for the SPI interface. [Verified] 3. Sensor Module – Analog and I²C Sub‑Circuits 3.1 BME280 Environmental Sensor - I²C Interface : Two pull‑up resistors (4.7 kΩ) are placed on the SDA and SCL lines. The resistors are labeled R24 and R25. The BME280 is mounted on the top layer, with the pull‑ups routed to the ESP32’s I²C pins. [Verified] - Power Supply : The sensor is powered from the 3.3 V plane, with a bypass capacitor (0.1 µF) placed close to VDD to filter supply noise. [Verified] 3.2 Ambient Light Sensor - Photodiode : A photodiode (likely a TMD) is mounted on the top side. The sensor’s o",
    "source_file": "08_designing_the_esp32_circuitry.docs.md",
    "chunk_id": 3
  },
  {
    "text": "t Light Sensor - Photodiode : A photodiode (likely a TMD) is mounted on the top side. The sensor’s output is routed to the ESP32’s ADC input. The designer uses a 4.7 kΩ pull‑up on the sensor’s output to provide a defined idle level. [Verified] - Signal Conditioning : No differential pair or length matching is required for this low‑speed analog signal. [Inference] 3.3 Microphone and Pre‑Amplifier - MAX4466 Pre‑Amplifier : The pre‑amplifier is a low‑noise op‑amp. The designer places the MAX4466 on the top layer and routes its input to the microphone. The microphone is a MEMS device that requires a bias voltage and a series resistor to limit current. The designer uses a 50 Ω resistor on the microphone’s output to match the input impedance of the pre‑amplifier. [Verified] - Signal Routing : Th",
    "source_file": "08_designing_the_esp32_circuitry.docs.md",
    "chunk_id": 4
  },
  {
    "text": "rophone’s output to match the input impedance of the pre‑amplifier. [Verified] - Signal Routing : The microphone’s analog output is routed to the ESP32’s ADC pin. The designer ensures the trace is short to minimize noise pickup. [Inference] 4. Design Decisions & Trade‑Offs 4.1 Layer Count vs. Cost - The board uses a 4‑layer stackup (top, inner power/ground, bottom). This balances cost and performance: a 4‑layer board is inexpensive for small boards while providing a solid reference plane for power and ground, which is essential for high‑speed signals like USB and SPI. [Speculation] 4.2 Test Points Placement - Test points are placed near the power plane to reduce the length of the test leads and to keep the pads accessible. The designer mirrors the capacitor placement to maintain symmetry, ",
    "source_file": "08_designing_the_esp32_circuitry.docs.md",
    "chunk_id": 5
  },
  {
    "text": "and to keep the pads accessible. The designer mirrors the capacitor placement to maintain symmetry, which also aids in assembly and inspection. [Verified] 4.3 Signal Integrity for SPI - In SPI mode, only MOSI, MISO, SCK, and CS are actively used. The designer leaves the D2 and D1 pins floating or tied to ground, as they are not required. This reduces routing complexity and avoids unnecessary noise coupling. [Verified] 4.4 Decoupling Strategy - The use of both 0.1 µF and 1 µF ceramic capacitors close to VDD and VCC pins is a standard practice to filter both high‑frequency and low‑frequency noise. The placement near the regulator ensures minimal loop area. [Verified] 4.5 Hierarchical Design - The board is split into hierarchical sheets: Core, Sensors, and User Interface. This modular approac",
    "source_file": "08_designing_the_esp32_circuitry.docs.md",
    "chunk_id": 6
  },
  {
    "text": "The board is split into hierarchical sheets: Core, Sensors, and User Interface. This modular approach simplifies the design process, allows independent review of each subsystem, and eases future modifications. [Verified] 5. Lessons Learned 1. Keep High‑Speed Traces Short – The USB and SPI traces are routed as short as possible to reduce skew and EMI. [Verified] 2. Use Test Points for Debugging – Adding dedicated test pads for critical signals (MOSI, MISO, SCK, CS) streamlines troubleshooting without disturbing the main circuitry. [Verified] 3. Mirror Components for Symmetry – Mirroring the decoupling capacitor placement ensures a balanced layout, which is beneficial for both assembly and thermal management. [Verified] 4. Follow Datasheet Guidelines – Pull‑up resistor values (4.7 kΩ) and bi",
    "source_file": "08_designing_the_esp32_circuitry.docs.md",
    "chunk_id": 7
  },
  {
    "text": "rmal management. [Verified] 4. Follow Datasheet Guidelines – Pull‑up resistor values (4.7 kΩ) and biasing schemes are taken directly from component datasheets, ensuring reliable operation. [Verified] 5. Simplify Where Possible – Unused I²C lines in SPI mode are left floating or tied to ground, reducing routing burden. [Verified] 6. Summary The PCB design integrates a Wi‑Fi capable microcontroller, USB connectivity, and a suite of environmental sensors into a compact, manufacturable board. Key design choices—such as a 4‑layer stackup, strategic decoupling, and the use of test points—balance performance, cost, and ease of assembly. The modular hierarchical structure facilitates future revisions and component updates while maintaining a clean, organized layout.",
    "source_file": "08_designing_the_esp32_circuitry.docs.md",
    "chunk_id": 8
  },
  {
    "text": "PCB Design Overview Design Objectives The board is intended to host an ESP‑32 microcontroller along with a suite of peripheral sensors (temperature, humidity, pressure, light, motion, etc.) and a user interface that includes a display, buttons, and a USB‑to‑serial bridge. The design must accommodate a 2‑layer prototype for rapid validation and a 4‑layer final version that delivers robust power distribution, reduced noise, and controlled‑impedance routing for high‑speed signals. The primary constraints are cost, manufacturability, and signal integrity. Prototype vs. Final Board 2‑Layer Prototype - Purpose : Quick, inexpensive validation of the schematic and component placement. - Stackup : Two copper layers (top and bottom) with no dedicated power or ground planes. - Advantages : Lower cost",
    "source_file": "09_adding_sensors_and_user_interface_components.docs.md",
    "chunk_id": 0
  },
  {
    "text": "o copper layers (top and bottom) with no dedicated power or ground planes. - Advantages : Lower cost, simpler fabrication, faster turnaround. - Limitations : Higher trace impedance, limited routing space, poorer power‑plane isolation, and increased susceptibility to EMI. - Trade‑off : Acceptable for early functional testing but not suitable for the final product where noise and power integrity are critical. [Verified] 4‑Layer Final - Purpose : Deliver a production‑grade board with reliable power distribution, controlled impedance for high‑speed signals, and reduced EMI. - Stackup : Typically two signal layers with an inner power plane and an inner ground plane, providing a reference plane for impedance control. - Advantages : Improved noise immunity, better thermal management, and the abil",
    "source_file": "09_adding_sensors_and_user_interface_components.docs.md",
    "chunk_id": 1
  },
  {
    "text": "r impedance control. - Advantages : Improved noise immunity, better thermal management, and the ability to route differential pairs with length matching. - Limitations : Higher cost and more complex fabrication. - Trade‑off : The cost increase is justified by the",
    "source_file": "09_adding_sensors_and_user_interface_components.docs.md",
    "chunk_id": 2
  },
  {
    "text": "Footprint Assignment and Schematic Validation Footprint Selection Strategy The design team opted for 0805 surface‑mount devices for the majority of resistors and decoupling capacitors. This choice reflects a common compromise between board density and manufacturing cost: 0805 components are small enough to support moderate component counts while still being inexpensive and readily available for automated pick‑and‑place assembly. [Verified] For high‑frequency decoupling, tandem (bypass) capacitors were selected, and a 1.0 mm test‑point pad was used for each test point. These pad dimensions are typical for test points that must accommodate probing equipment without compromising the surrounding signal integrity. [Inference] Standard 2.54 mm pitch connectors were chosen for the JST and B2B con",
    "source_file": "10_validating_the_schematic_and_assigning_footprints.docs.md",
    "chunk_id": 0
  },
  {
    "text": " signal integrity. [Inference] Standard 2.54 mm pitch connectors were chosen for the JST and B2B connectors to guarantee compatibility with off‑the‑shelf housings and to simplify the assembly process. [Verified] Efficient Footprint Assignment in KiCad KiCad’s schematic editor allows the user to assign footprints to symbols in a single operation. By selecting multiple symbols and applying a filter in the footprint browser, the designer could narrow the search to the desired 0805 or tandem capacitor footprints, thereby reducing visual clutter and speeding up the assignment process. [Verified] The filter mechanism is particularly useful when a project contains a large number of footprint libraries; it limits the displayed options to those that match the current search string, making it easier",
    "source_file": "10_validating_the_schematic_and_assigning_footprints.docs.md",
    "chunk_id": 1
  },
  {
    "text": "ies; it limits the displayed options to those that match the current search string, making it easier to locate the correct package. [Verified] After assigning footprints, the designer saved the project, ensuring that the footprint associations were persisted for the subsequent layout stage. [Verified] Electrical Rule Check (ERC) Workflow Before proceeding to the layout editor, the schematic was subjected to an Electrical Rule Check. ERC automatically flags several classes of violations: 1. Unconnected power pins – The check reported that a power pin was not driven by a power net. The designer resolved this by duplicating the power‑flag symbol and connecting it to the appropriate net. This action informs the ERC engine that the net is a power supply, preventing further power‑pin warnings. [",
    "source_file": "10_validating_the_schematic_and_assigning_footprints.docs.md",
    "chunk_id": 2
  },
  {
    "text": "tion informs the ERC engine that the net is a power supply, preventing further power‑pin warnings. [Verified] 2. Missing ground connections – A missing ground pin was identified. The designer added a ground symbol and connected the pin, satisfying the ERC requirement that all ground pins be tied to a common ground net. [Verified] 3. Library footprint configuration – ERC warned that certain footprint libraries were not included in the current configuration. Although the footprints existed within the project file, the configuration did not reference the library, leading to a warning. The designer chose to ignore this warning until layout validation. [Verified] 4. Symbol–library mismatch – A copy of a symbol in the project did not match the original library definition, likely due to a prior e",
    "source_file": "10_validating_the_schematic_and_assigning_footprints.docs.md",
    "chunk_id": 3
  },
  {
    "text": "py of a symbol in the project did not match the original library definition, likely due to a prior edit that moved a label. Since the mismatch did not affect functionality, the warning was suppressed. [Verified] 5. Pin‑type conflicts – ERC reported that pins of type “B directional” and “power output” were connected in a way that could potentially cause a conflict. After inspecting the connections, the designer confirmed that the net assignments were correct and suppressed the warning. [Verified] The ERC interface offers several mechanisms to manage warnings: - Ignore – Temporarily suppresses a warning for the current session. - Exclude – Adds a permanent exclusion that can be reinstated later via the exclusion list. - Ignore all – Suppresses all warnings of the same type, useful when a pat",
    "source_file": "10_validating_the_schematic_and_assigning_footprints.docs.md",
    "chunk_id": 4
  },
  {
    "text": "r via the exclusion list. - Ignore all – Suppresses all warnings of the same type, useful when a pattern of benign warnings is present. These options allow designers to focus on critical violations while deferring non‑critical issues to the layout stage. [Verified] Best Practices for Footprint Assignment - Use multi‑select to assign identical footprints to many symbols at once, reducing repetitive work. [Verified] - Apply footprint filters to limit the search space to relevant packages, improving navigation speed. [Verified] - Verify that each symbol’s footprint matches the library definition before proceeding to layout; mismatches can cause ERC and DRC failures. [Verified] - Mark power nets with a power‑flag symbol",
    "source_file": "10_validating_the_schematic_and_assigning_footprints.docs.md",
    "chunk_id": 5
  },
  {
    "text": "PCB Design Overview for a Compact 2‑Layer Board Design Objectives and Constraints The board is intended to house a microcontroller unit (MCU) with an integrated PCB antenna, high‑speed memory interfaces, and a set of user‑interface components (SD card, USB port, buttons, charging port, LEDs, and sensors). The primary",
    "source_file": "11_setting_up_the_pcb_layout_editor.docs.md",
    "chunk_id": 0
  },
  {
    "text": "PCB Design Overview Component Placement Strategy The active circuitry is positioned centrally on the board to minimise trace lengths and to keep the most critical signals short and well‑shielded. Passive elements such as decoupling capacitors are placed immediately adjacent to the active devices they serve, which reduces the loop",
    "source_file": "12_component_placement_and_board_outline_refinement.docs.md",
    "chunk_id": 0
  },
  {
    "text": "Routing and Copper Zones Overview The routing phase of a multilayer board is where the abstract schematic is translated into a physical trace network that satisfies electrical, thermal, and manufacturability requirements. This chapter focuses on the manual routing approach, the systematic creation of copper zones for reference planes, and the practical techniques used to connect component pads to those planes. The goal is to achieve low‑impedance, low‑skew power delivery while maintaining clean, manufacturable geometry for high‑speed signals that will follow. Manual Routing vs. Auto‑Router Choosing manual routing over an auto‑router is a deliberate design decision that trades off speed for control. Auto‑routers can quickly fill dense nets but often produce sub‑optimal trace widths, via pla",
    "source_file": "13_routing_and_copper_zones.docs.md",
    "chunk_id": 0
  },
  {
    "text": "ontrol. Auto‑routers can quickly fill dense nets but often produce sub‑optimal trace widths, via placement, and impedance‑matching for high‑speed signals. Manual routing allows the designer to: - Enforce consistent trace widths for power and ground planes, ensuring predictable impedance and current capacity. - Place vias strategically to minimize via count and avoid blind or buried via usage unless necessary. - Match differential pair lengths and maintain skew within tight tolerances. The designer acknowledges that the auto‑router may still be used for low‑priority nets or as a fallback, but the primary routing effort remains manual. [Verified] Copper Plane Strategy Ground Plane A single, continuous ground plane is created on the second inner layer (the reference plane). The plane is named",
    "source_file": "13_routing_and_copper_zones.docs.md",
    "chunk_id": 1
  },
  {
    "text": "ntinuous ground plane is created on the second inner layer (the reference plane). The plane is named gnd and is filled with a solid fill to maximize copper area and reduce impedance. The plane is also used as a reference for all other power zones, providing a low‑impedance return path for high‑current nets. Naming conventions such as gnd D J2 or gnd D top one help keep the search panel organized and avoid confusion when multiple zones share the same net. [Verified] Power Planes Three primary power zones are defined: - 3.3 V Plane – Encompasses all 3.3 V components and is placed on the first inner layer. - 5 V Plane – Covers the 5 V supply, often used for the regulator and USB VBUS. - VBUS Plane – Dedicated to the USB VBUS line, ensuring a clean return path for USB power. Each plane is crea",
    "source_file": "13_routing_and_copper_zones.docs.md",
    "chunk_id": 2
  },
  {
    "text": "ane – Dedicated to the USB VBUS line, ensuring a clean return path for USB power. Each plane is created as a copper zone with solid fill, which improves current carrying capacity and reduces the risk of impedance discontinuities compared to a hatch fill. The zones are named descriptively (e.g., 3.3 volt top one, 5 volt top one) to aid navigation in the search panel. [Verified] Zone Creation Process 1. Tool Selection – The zone tool is chosen from the layer stack (inner or outer) depending on the target plane. 2. Naming – Each zone is given a clear, descriptive name that reflects its net and location. 3. Fill Style – Solid fill is preferred over hatch for power planes because it provides a continuous copper area, reducing resistance and improving thermal performance. 4. Enclosure – The zone",
    "source_file": "13_routing_and_copper_zones.docs.md",
    "chunk_id": 3
  },
  {
    "text": "ntinuous copper area, reducing resistance and improving thermal performance. 4. Enclosure – The zone is drawn to encompass all relevant pads and component footprints, ensuring that the plane covers the entire area needed for the net. 5. Fill – The b key (or equivalent) is used to apply the fill, which automatically connects the zone to any pads or vias that intersect it. These steps are repeated for each power plane and for the ground plane. [Verified] Connecting Pads to Zones Via Placement Pads on the top layer that need to connect to an inner plane are linked via through‑hole or buried vias. The designer uses a VR (via) to connect the pad to the zone, ensuring that the via’s net matches the zone’s net. If a via is not automatically connected, the designer can manually change the via’s ne",
    "source_file": "13_routing_and_copper_zones.docs.md",
    "chunk_id": 4
  },
  {
    "text": "e zone’s net. If a via is not automatically connected, the designer can manually change the via’s net property to the correct plane. This approach guarantees that the pad is electrically tied to the reference plane, providing a low‑impedance path. [Verified] Thermal Reliefs Thermal reliefs are applied to pads that carry significant current. The designer selects a via size of 0.5 mm with a 0.3 mm clearance to provide a robust connection while still allowing the pad to dissipate heat effectively. Solid fill zones also help reduce the need for extensive thermal reliefs because the plane itself provides a large copper area for heat sinking. [Inference] Via Stackup The stackup includes two inner layers: the first inner layer for the ground plane and the second inner layer for the power planes. ",
    "source_file": "13_routing_and_copper_zones.docs.md",
    "chunk_id": 5
  },
  {
    "text": "layers: the first inner layer for the ground plane and the second inner layer for the power planes. Vias that connect top layer pads to these inner planes are typically through‑hole or buried, depending on the board’s manufacturing capabilities. The designer ensures that the via diameter and pad clearance meet the design rules for the chosen manufacturing process. [Speculation] Design Rules and Constraints | Parameter | Typical Value | Rationale | |-----------|---------------|-----------| | Clearance | 0.2 mm (adjusted for pad inclusion) | Ensures pads are fully connected to zones without violating DRC. | | Trace Width | Minimum 0.2 mm for high‑current tracks | Provides sufficient current capacity while staying within board size constraints. | | Via Diameter | 0.3 mm | Balances current car",
    "source_file": "13_routing_and_copper_zones.docs.md",
    "chunk_id": 6
  },
  {
    "text": "pacity while staying within board size constraints. | | Via Diameter | 0.3 mm | Balances current carrying capability and manufacturability. | | Thermal Relief | 0.5 mm pad with 0.3 mm clearance | Allows heat dissipation while maintaining pad integrity. | | Fill Style | Solid | Improves electrical performance and reduces impedance discontinuities. | These rules are enforced through DRC and ERC checks, ensuring that all nets meet clearance, width, and impedance requirements. [Verified] Practical Tips - Locking Groups – Once a zone or via group is finalized, it is locked to prevent accidental movement during subsequent routing steps. - Search Panel – The search panel’s “Zones” tab is used to review all created zones, verify their net assignments, and rename them if necessary. - Adjusting Clea",
    "source_file": "13_routing_and_copper_zones.docs.md",
    "chunk_id": 7
  },
  {
    "text": "view all created zones, verify their net assignments, and rename them if necessary. - Adjusting Clearance – If a pad is not included in a zone due to clearance settings, reducing the clearance to 0.2 mm can resolve the issue. This demonstrates the importance of fine‑tuning design rules for specific layout scenarios. [Inference] - Solid Fill Preference – Using solid fill for power planes yields a lower resistance path compared to hatch fill, which is especially important for high‑current nets such as VBAT and USB power. [Verified] Differential Pairs and High‑Speed Signals After establishing the copper planes and ensuring all power and ground connections are robust, the next routing phase focuses on differential pairs and high‑speed clock signals. These traces require careful length matching",
    "source_file": "13_routing_and_copper_zones.docs.md",
    "chunk_id": 8
  },
  {
    "text": "ses on differential pairs and high‑speed clock signals. These traces require careful length matching, controlled impedance, and minimal skew. The groundwork laid by the copper zones—particularly the solid ground plane and power planes—provides a stable reference for these high‑speed signals, reducing noise and ensuring signal integrity. [Speculation] Summary A disciplined approach to copper zone creation, pad‑to‑zone connectivity, and manual routing yields a board that meets electrical performance targets while remaining manufacturable. Solid fill zones, strategic via placement, and clear naming conventions collectively contribute to a reliable, high‑density PCB design. The subsequent routing of differential pairs and high‑speed signals will build upon this foundation to achieve the desire",
    "source_file": "13_routing_and_copper_zones.docs.md",
    "chunk_id": 9
  },
  {
    "text": "g of differential pairs and high‑speed signals will build upon this foundation to achieve the desired signal integrity.",
    "source_file": "13_routing_and_copper_zones.docs.md",
    "chunk_id": 10
  },
  {
    "text": "Differential Pairs and High‑Speed Signal Routing USB Differential Pair Routing The USB interface requires two tightly coupled differential traces, DP and DM, that must be routed with identical lengths and controlled impedance. The designer began by selecting the differential‑pair tool (keyboard shortcut 6 ) and attempted to connect the pads on the bottom layer. The initial attempt failed because the pads were too close together and the clearance rule was violated. By unlocking and shifting the USB connector component slightly to the left, the designer created the necessary space and successfully routed the pair. The traces were then refined using the D key, which allows 45°‑mode dragging, to achieve a more symmetrical layout and to avoid crossing the VBUS pad. The VBUS net was routed separ",
    "source_file": "14_differential_pairs_and_high-speed_signal_routing.docs.md",
    "chunk_id": 0
  },
  {
    "text": " achieve a more symmetrical layout and to avoid crossing the VBUS pad. The VBUS net was routed separately, using a via to connect the pad to the VBUS plane, rather than forcing the differential pair to weave around it. This approach preserves the integrity of the differential pair while satisfying the VBUS routing requirement. [Verified] I²C (I²C) Routing The I²C bus (SCL and SDA) operates at up to 400 kHz in standard mode and 1 MHz in fast mode. Although strict length matching is not critical for I²C, the designer still aimed for minimal skew to maintain signal integrity. The SDA and SCL traces were routed on the top layer, with vias used to transition to the bottom layer where necessary. The designer moved the SPI component (U6) downward to isolate the I²C traces from high‑speed signals,",
    "source_file": "14_differential_pairs_and_high-speed_signal_routing.docs.md",
    "chunk_id": 1
  },
  {
    "text": "he designer moved the SPI component (U6) downward to isolate the I²C traces from high‑speed signals, thereby reducing crosstalk. The SCL trace was longer than SDA, so the designer increased SDA’s length by routing it around the ESP32 area and then fine‑tuned the length using the length‑tuning tool (shortcut 7 ). By iteratively adding and removing small segments, the designer achieved a length difference of less than 0.6 mm, well within acceptable tolerances for I²C. [Verified] [Inference] Length Matching and Skew Length matching is critical for differential pairs and for any high‑speed bus where timing skew can affect data integrity. The designer measured the routed lengths: SCL was 68.29 mm and SDA was 52.3 mm. Using the length‑tuning tool, the SDA trace was extended to 68.9 mm, bringing ",
    "source_file": "14_differential_pairs_and_high-speed_signal_routing.docs.md",
    "chunk_id": 2
  },
  {
    "text": " and SDA was 52.3 mm. Using the length‑tuning tool, the SDA trace was extended to 68.9 mm, bringing the two traces within 0.6 mm of each other. This process involved drawing additional segments, then trimming them with the same tool until the desired length was reached. The final lengths were verified by the DRC, confirming that the skew was acceptable for the target data rates. [Verified] [Inference] Design Tools and Shortcuts The workflow relied heavily on keyboard shortcuts to accelerate routing: - 6 – Select differential‑pair tool. - X – Draw a straight trace. - D – Drag in 45° mode, useful for creating clean, orthogonal routes. - V – Place a via. - 7 – Length‑tune a single track. These shortcuts, combined with component unlocking and repositioning, allowed the designer to quickly reso",
    "source_file": "14_differential_pairs_and_high-speed_signal_routing.docs.md",
    "chunk_id": 3
  },
  {
    "text": "shortcuts, combined with component unlocking and repositioning, allowed the designer to quickly resolve clearance issues and refine trace geometry. [Verified] [Inference] Practical Layout Decisions Several practical decisions were made to balance performance, manufacturability, and board space: 1. Component Repositioning – Moving the USB connector and the SPI component created clearance for differential pairs and isolated sensitive I²C traces from high‑speed signals. 2. Layer Management – The designer routed most high‑speed signals on the top layer, using vias to transition to the bottom layer only when necessary, thereby reducing the number of layer changes and potential impedance discontinuities. 3. Via Placement – Vias were placed close to the trace ends to minimize stub length, and the",
    "source_file": "14_differential_pairs_and_high-speed_signal_routing.docs.md",
    "chunk_id": 4
  },
  {
    "text": "uities. 3. Via Placement – Vias were placed close to the trace ends to minimize stub length, and the designer used standard through‑hole vias rather than blind or buried vias, simplifying manufacturing. 4. Trace Width and Spacing – While exact dimensions are not specified, the designer maintained consistent spacing between differential pairs and adhered to the board’s clearance rules, ensuring manufacturability and signal integrity. 5. Isolation of Sensitive Nets – I²C traces were routed away from the SPI bus and other high‑speed lines, reducing crosstalk and improving noise immunity. These decisions reflect a trade‑off between board area, component density, and signal quality. [Inference] [Speculation] Best Practices and Lessons Learned - Use the Differential‑Pair Tool Early – It automati",
    "source_file": "14_differential_pairs_and_high-speed_signal_routing.docs.md",
    "chunk_id": 5
  },
  {
    "text": "Speculation] Best Practices and Lessons Learned - Use the Differential‑Pair Tool Early – It automatically enforces equal trace lengths and spacing, reducing manual effort. - Maintain Adequate Clearance – Always check clearance rules before routing; moving components can resolve conflicts without compromising the design. - Employ 45° Routing for Orthogonal Traces – The D key facilitates clean, orthogonal routing, which helps maintain controlled impedance. - Length‑Tune Critical Nets – Even for buses where skew is not critical, small mismatches can accumulate; use the length‑tuning tool to fine‑tune trace lengths. - Isolate Sensitive Nets – Keep low‑speed, high‑noise‑tolerant nets (e.g., I²C) away from high‑speed buses to reduce crosstalk. - Document Component Movements – Record any repositi",
    "source_file": "14_differential_pairs_and_high-speed_signal_routing.docs.md",
    "chunk_id": 6
  },
  {
    "text": "away from high‑speed buses to reduce crosstalk. - Document Component Movements – Record any repositioning of components, as it may affect other nets or thermal considerations. - Validate with DRC/ERC – After routing, run design rule checks to ensure all clearance, impedance, and net connectivity constraints are satisfied. By following these practices, designers can achieve reliable high‑speed signal routing while maintaining manufacturability and board performance.",
    "source_file": "14_differential_pairs_and_high-speed_signal_routing.docs.md",
    "chunk_id": 7
  },
  {
    "text": "PCB Design Review Summary Design Overview The board integrates an ESP32 module, a USB connector, and a set of peripheral components such as LEDs, buttons, and a 3.3 V regulator. A 4‑layer stackup is employed, with the top layer dedicated to signal routing, the bottom layer serving as a ground plane, and two internal layers providing additional signal and power planes. The 3.3 V net class is defined with a 0.8 mm trace width, a 0.5 mm via size, and a 0.3 mm clearance to ground. The design follows a standard DFM approach, ensuring that all trace widths, clearances, and via sizes are within the capabilities of the selected manufacturer. [Verified] Trace Width and Net‑Class Decisions The 3.3 V net class uses a 0.8 mm trace width, which satisfies both clearance and manufacturability constraints",
    "source_file": "15_power_traces_and_signal_routing.docs.md",
    "chunk_id": 0
  },
  {
    "text": "et class uses a 0.8 mm trace width, which satisfies both clearance and manufacturability constraints. This width is large enough to accommodate the current requirements of the ESP32 module while keeping the board cost low by avoiding the need for additional layers or complex impedance control. The 0.5 mm via size for the 3.3 V net class provides sufficient current handling and reduces the risk of via failure during assembly. [Verified] For the USB differential pair, a 0.8 mm trace width and 0.8 mm spacing are used. The pair is routed with a 0.8 mm length to match the differential impedance requirements of the USB specification. Length matching is critical for maintaining signal integrity, especially at the high data rates of USB 2.0. The designer chose to keep the differential pair short a",
    "source_file": "15_power_traces_and_signal_routing.docs.md",
    "chunk_id": 1
  },
  {
    "text": "pecially at the high data rates of USB 2.0. The designer chose to keep the differential pair short and straight to minimize skew and avoid the need for complex micro‑via stitching. [Inference] Via Management Through‑hole vias are used to connect the 3.3 V copper plane to the corresponding pads. The designer opted for a single‑spoke thermal relief for the large copper area that connects the ground plane to the 3.3 V plane. Although a second spoke would be preferable for thermal management, the limited space on the board made it impractical to add an additional spoke. This decision was accepted because the thermal load is modest and the manufacturer can accommodate a single‑spoke relief. [Inference] The ESP32 footprint contains a solder‑mask aperture that touches an adjacent pad. This issue ",
    "source_file": "15_power_traces_and_signal_routing.docs.md",
    "chunk_id": 2
  },
  {
    "text": "rence] The ESP32 footprint contains a solder‑mask aperture that touches an adjacent pad. This issue was resolved by editing the footprint and moving the offending dot to a location that does not interfere with the solder mask. The designer chose to exclude the violation from the DRC because the footprint is fixed by the manufacturer and does not affect the board’s performance. [Verified] Differential Pair Routing The USB differential pair is routed with a 0.8 mm spacing and a 0.8 mm trace width. The pair is kept as",
    "source_file": "15_power_traces_and_signal_routing.docs.md",
    "chunk_id": 3
  },
  {
    "text": "Design Rule Check and Final Refinements Overview Before a PCB can be handed off to a manufacturer, it must satisfy a set of design rules that guarantee manufacturability, reliability, and performance. The Design Rule Check (DRC) is the first gatekeeper, catching violations such as insufficient clearance, trace width mismatches, or unconnected pads. Once the DRC passes, the next step is a DesignŌĆæforŌĆæManufacturability (DFM) review, which focuses on how the board will actually be fabricated and assembled. This chapter details the final refinements that are typically performed after a clean DRC, with an emphasis on geometry, redundancy elimination, and trace length optimization. Design Rule Check (DRC) - Purpose : Verify that the layout obeys the constraints defined by the fabrication hous",
    "source_file": "16_design_rule_check_and_final_refinements.docs.md",
    "chunk_id": 0
  },
  {
    "text": "Check (DRC) - Purpose : Verify that the layout obeys the constraints defined by the fabrication house (clearances, widths, via sizes, etc.). - Outcome : A clean DRC indicates that the board can be fabricated without mechanical or electrical failures. - Best Practice : Run the DRC after every major change and before any DFM analysis. - [Verified] : A DRC that reports no violations is a prerequisite for proceeding to DFM. DesignŌĆæforŌĆæManufacturability (DFM) Review DFM tools analyze the board from the manufacturerŌĆÖs perspective, flagging features that could increase cost, reduce yield, or cause assembly issues. Common DFM concerns include: - Sharp 90┬░ corners : While a 90┬░ turn is acceptable for many processes, it can create a highŌĆæstress point in the copper and may lead to solder jo",
    "source_file": "16_design_rule_check_and_final_refinements.docs.md",
    "chunk_id": 1
  },
  {
    "text": "able for many processes, it can create a highŌĆæstress point in the copper and may lead to solder joint failures. - Redundant segments : Extra turns or unnecessary track segments increase board area and can introduce impedance discontinuities. - Long trace runs : Excessive length can degrade signal integrity, especially for highŌĆæspeed signals. - [Inference] : The DFM tool will also catch issues such as via density, pad spacing, and thermal relief, but these are not explicitly mentioned in the transcript. 90┬░ Angles - Why they matter : Sharp corners can concentrate current and solder, leading to voids or cracks during reflow. - Mitigation : Replace 90┬░ turns with 45┬░ or 135┬░ angles, or use a small radius (e.g., 0.15ŌĆ»mm) to smooth the transition. - [Verified] : Most DFM tools flag 90",
    "source_file": "16_design_rule_check_and_final_refinements.docs.md",
    "chunk_id": 2
  },
  {
    "text": "use a small radius (e.g., 0.15ŌĆ»mm) to smooth the transition. - [Verified] : Most DFM tools flag 90┬░ corners as a potential manufacturability issue. Redundant Segments and Track Simplification - Problem : Unnecessary turns or overlapping segments increase board area and can create impedance mismatches. - Solution : Redraw the track to a straight line where possible, or use a single continuous segment. - [Inference] : The transcript notes the removal of a redundant segment, which is a standard cleanup step before finalization. Trace Length Optimization - Impact on performance : Longer traces can introduce unwanted inductance and capacitance, affecting highŌĆæspeed signals. - Approach : Shorten the path by eliminating detours, using a more direct routing path, or reŌĆærouting the trace ent",
    "source_file": "16_design_rule_check_and_final_refinements.docs.md",
    "chunk_id": 3
  },
  {
    "text": "ten the path by eliminating detours, using a more direct routing path, or reŌĆærouting the trace entirely. - [Speculation] : While the transcript mentions reducing length, the exact benefit depends on the signal frequency and impedance requirements. Final Refinement Workflow 1. Select and Redraw - Use the PCB editorŌĆÖs ŌĆ£selectŌĆØ tool to isolate problematic segments. - Redraw with a thicker trace if the current width is marginal for the required current or if the DFM tool flags it. - [Inference] This step improves manufacturability by ensuring adequate copper for current handling. 2. Eliminate Redundancies - Scan the board for overlapping or unnecessary turns. - Replace them with a single, straight segment. - [Verified] Simplifying the layout reduces the risk of solder bridging and ease",
    "source_file": "16_design_rule_check_and_final_refinements.docs.md",
    "chunk_id": 4
  },
  {
    "text": ", straight segment. - [Verified] Simplifying the layout reduces the risk of solder bridging and eases assembly. 3. Optimize Lengths - Identify the longest traces, especially those carrying highŌĆæspeed signals. - ReŌĆæroute to a more direct path, or use a different layer if available. - [Speculation] Shorter traces can improve signal integrity, but the tradeŌĆæoff with routing complexity must be considered. 4. ReŌĆærun DRC - After each change, perform a quick DRC to ensure no new violations were introduced. - [Verified] A clean DRC after each refinement guarantees that the board remains manufacturable. 5. Generate DFM Report - Run the DFM tool to confirm that all manufacturability concerns have been addressed. - Review the report for any remaining ŌĆ£softŌĆØ warnings that may still impact ",
    "source_file": "16_design_rule_check_and_final_refinements.docs.md",
    "chunk_id": 5
  },
  {
    "text": "ave been addressed. - Review the report for any remaining ŌĆ£softŌĆØ warnings that may still impact yield. - [Inference] A clean DFM report is the final green light before sending the design to the fab. Lessons Learned - Early DRC compliance is essential : A clean DRC eliminates the most obvious manufacturability issues, allowing focus on finer details. - Geometry matters : Even seemingly minor features like 90┬░ corners or redundant segments can have outsized effects on yield and reliability. - Iterative refinement : Small, incremental changesŌĆöredrawing a track, removing a redundant segment, shortening a traceŌĆöcollectively produce a robust design. - DFM is a secondŌĆælevel check : It catches issues that DRC may miss, such as via density or pad spacing that affect assembly. - Documenta",
    "source_file": "16_design_rule_check_and_final_refinements.docs.md",
    "chunk_id": 6
  },
  {
    "text": "tches issues that DRC may miss, such as via density or pad spacing that affect assembly. - Documentation and traceability : Keep a record of each refinement, including the rationale and the resulting DFM/DRC status, to aid future revisions or audits. By following these practices, designers can ensure that their PCB not only meets electrical specifications but also aligns with the practical realities of modern manufacturing processes.",
    "source_file": "16_design_rule_check_and_final_refinements.docs.md",
    "chunk_id": 7
  },
  {
    "text": "Design for Manufacturing (DFM) Checks Overview Design for Manufacturing (DFM) is a critical phase that bridges the gap between a functional electrical design and a manufacturable physical board. While Electrical Rule Checks (ERC) and Design Rule Checks (DRC) ensure that the schematic and layout meet electrical specifications, DFM verifies that the board can be fabricated, assembled, and tested without costly re‑work or yield loss. This section documents the workflow, tools, common findings, and corrective actions applied during a typical DFM review of an ESP‑32 based prototype. Tool Selection NextPCB DFM Checker The NextPCB DFM Checker is a free, cross‑platform application that parses Gerber files and generates a detailed report of manufacturability issues. Two interfaces are available: 1.",
    "source_file": "17_design_for_manufacturing__dfm__checks.docs.md",
    "chunk_id": 0
  },
  {
    "text": " files and generates a detailed report of manufacturability issues. Two interfaces are available: 1. Online Web Interface – convenient for quick checks but limited in feature set. 2. Windows Desktop Application – offers a richer set of diagnostics, including a 3‑D visualizer and drill‑to‑copper analysis. The Windows application was chosen for its comprehensive reporting and the ability to interactively navigate to problem locations. The KiCad 9 plugin version of the tool was not usable due to compatibility issues with the release candidate, so all DFM checks were performed offline. > [Verified] The Windows app provides a 3‑D view that highlights problematic areas in color (green = OK, orange = warning, red = error). Exporting Gerbers 1. Plot Gerbers – In KiCad, the Plot dialog is used to g",
    "source_file": "17_design_for_manufacturing__dfm__checks.docs.md",
    "chunk_id": 1
  },
  {
    "text": " = warning, red = error). Exporting Gerbers 1. Plot Gerbers – In KiCad, the Plot dialog is used to generate Gerber files for all layers. The Proto file name extension is selected to match the manufacturing vendor’s expectations. 2. Generate Drill Files – The Generate Drill Files option creates the necessary drill and drill‑to‑copper files. 3. Organize Output – All Gerber and drill files are placed in a dedicated directory (e.g., ESP32 Project Gers) for easy import into the DFM tool. > [Verified] The directory structure and file naming convention are critical for the DFM tool to correctly map layers. Running the DFM Analysis The DFM tool accepts the Gerber set via a drag‑and‑drop interface. Upon loading, the tool performs a rapid analysis, producing a color‑coded report: - Green – No issues",
    "source_file": "17_design_for_manufacturing__dfm__checks.docs.md",
    "chunk_id": 2
  },
  {
    "text": "pon loading, the tool performs a rapid analysis, producing a color‑coded report: - Green – No issues detected. - Orange – Potential concerns that merit review. - Red – Deficiencies that must be corrected before manufacturing. The 3‑D viewer allows the user to click on a highlighted region, automatically panning to the exact location in the layout. Interpreting Common DFM Findings Via‑to‑Trace Clearance A frequent red‑flag is a via that is too close to a trace. The tool reports the clearance and the minimum required value. In the example, a via near a USB port trace was flagged, but the designer confirmed that the geometry is acceptable for the chosen manufacturer. When a violation is confirmed, the solution is to shift the via or widen the adjacent trace. > [Inference] The designer’s decis",
    "source_file": "17_design_for_manufacturing__dfm__checks.docs.md",
    "chunk_id": 3
  },
  {
    "text": "ed, the solution is to shift the via or widen the adjacent trace. > [Inference] The designer’s decision to ignore the violation indicates that the manufacturer’s tolerance for via‑to‑trace clearance is more generous than the tool’s default. Copper‑to‑Edge Clearance Inner copper layers sometimes extend too close to the board edge, risking short‑circuiting during edge‑cutting. The DFM report highlights these zones. The fix involves adjusting the zone clearance to a safe value (e.g., 0.2 mm) and refilling the zones. > [Verified] Adjusting the clearance in the zone properties and refilling resolves the issue. Drill‑to‑Copper Spacing Drill holes that are too close to copper pads or traces can cause solder bridges. The DFM tool flags such cases. In the transcript, the USB connector’s drill spaci",
    "source_file": "17_design_for_manufacturing__dfm__checks.docs.md",
    "chunk_id": 4
  },
  {
    "text": "se solder bridges. The DFM tool flags such cases. In the transcript, the USB connector’s drill spacing was flagged but later verified as acceptable by the manufacturer. > [Inference] The designer relied on vendor documentation to confirm that the spacing met their process capability. Anular Ring Size The tool reports the annular ring (the copper pad surrounding a plated hole). A red flag indicates a ring smaller than the minimum. The designer inspected the actual dimensions: a 0.5 mm pad with a 0.3 mm hole yields a 0.2 mm ring, which exceeds the 0.127 mm minimum. Therefore, no action was required. > [Verified] The calculation confirms compliance with the minimum annular ring requirement. Silk Screen Design Considerations While DFM focuses on manufacturability, the silk screen layer also im",
    "source_file": "17_design_for_manufacturing__dfm__checks.docs.md",
    "chunk_id": 5
  },
  {
    "text": "k Screen Design Considerations While DFM focuses on manufacturability, the silk screen layer also impacts assembly and usability. The designer chose to prioritize informative silk screens over mounting holes, removing a few holes to free space for labels and graphics. Key Practices - Functional Grouping – Draw borders around related components (e.g., sound sensor, LED array) to aid assembly and debugging. - Clear Labels – Use concise, descriptive text for pins, power rails, and status LEDs. Avoid clutter by hiding default reference designators when custom labels are added. - Mounting Hole Management – Evaluate the necessity of each mounting hole; if the board is a prototype or educational kit, some holes can be omitted to reduce cost and complexity. - Layer Allocation – Reserve the top sil",
    "source_file": "17_design_for_manufacturing__dfm__checks.docs.md",
    "chunk_id": 6
  },
  {
    "text": "t, some holes can be omitted to reduce cost and complexity. - Layer Allocation – Reserve the top silk screen for primary information; the bottom layer can hold supplementary data or additional labels. > [Speculation] Removing mounting holes may affect mechanical stability in a production environment, but for a prototype board the trade‑off is acceptable. Lessons Learned 1. Tool Compatibility Matters – The KiCad plugin’s incompatibility with the latest release candidate forced a switch to the standalone Windows app. Future projects should verify plugin stability before committing to a workflow. 2. Vendor Tolerances Can Differ – Some red flags (via‑to‑trace, drill spacing) were accepted after consulting manufacturer specifications. Always cross‑check tool defaults against vendor datasheets. ",
    "source_file": "17_design_for_manufacturing__dfm__checks.docs.md",
    "chunk_id": 7
  },
  {
    "text": "consulting manufacturer specifications. Always cross‑check tool defaults against vendor datasheets. 3. Iterative Fixes Reduce Re‑work – The ability to adjust zone clearance and refill zones directly in the layout saves time compared to manual Gerber editing. 4. Silk Screen vs. Mechanical Features – Prioritizing informative silk screens can justify the removal of non‑essential mounting holes, especially in low‑volume or educational builds. Best‑Practice Checklist for DFM Reviews | Category | Recommended Action | |----------|--------------------| | Via‑to‑Trace | Verify clearance against vendor specs; shift via or widen trace if necessary. | | Copper‑to‑Edge | Set zone clearance to at least 0.2 mm; refill zones after adjustment. | | Drill‑to‑Copper | Confirm spacing with manufacturer; docume",
    "source_file": "17_design_for_manufacturing__dfm__checks.docs.md",
    "chunk_id": 8
  },
  {
    "text": "2 mm; refill zones after adjustment. | | Drill‑to‑Copper | Confirm spacing with manufacturer; document acceptable ranges. | | Annular Ring | Ensure pad‑hole geometry yields a ring ≥ 0.127 mm. | | Silk Screen | Group functional blocks, use clear labels, and evaluate mounting hole necessity. | > [Verified] These actions align with standard PCB manufacturing guidelines and reduce the likelihood of costly re‑work. Best Practices for Future DFM Reviews - Early DFM Integration – Run DFM checks after each major layout change to catch issues before they compound. - Layer‑by‑Layer Validation – Inspect each layer’s Gerber output separately; this helps isolate layer‑specific problems such as copper‑to‑edge or drill‑to‑copper violations. - Vendor Collaboration – Maintain an open line with the fabricat",
    "source_file": "17_design_for_manufacturing__dfm__checks.docs.md",
    "chunk_id": 9
  },
  {
    "text": "edge or drill‑to‑copper violations. - Vendor Collaboration – Maintain an open line with the fabrication and assembly vendor; their process documentation often contains tolerances that differ from generic tool defaults. - Documentation of Decisions – Record any deviations from tool recommendations, including the rationale and supporting vendor data. This documentation aids future audits and supports traceability. > [Verified] A disciplined DFM review, coupled with thoughtful silk screen design, ensures that a prototype board is both manufacturable and user‑friendly, setting a solid foundation for scaling to production.",
    "source_file": "17_design_for_manufacturing__dfm__checks.docs.md",
    "chunk_id": 10
  },
  {
    "text": "Adding Silkscreen and Final Touches Silkscreen is the final visual layer that communicates component orientation, test points, and branding to the end‑user and assembly personnel. In this stage of the design, the focus shifts from electrical performance to manufacturability, assembly, and user experience. The following sections distill the key decisions, constraints, and best practices that emerged during the finalization of the board. Silkscreen Design Considerations Text and logos must be legible from the intended viewing angle while respecting clearance rules. The design employed a consistent text geometry for all labels, rotating the entire block by 90° to match the board’s mounting orientation. This approach guarantees uniform font height and spacing, which simplifies optical inspecti",
    "source_file": "18_adding_silkscreen_and_final_touches.docs.md",
    "chunk_id": 0
  },
  {
    "text": "ntation. This approach guarantees uniform font height and spacing, which simplifies optical inspection during assembly. The inclusion of a company logo and a Tech Expo badge demonstrates how branding can be integrated without compromising pad clearance or test‑point visibility. Clearance between silkscreen and component pads is critical; a minimum of 0.15 mm (or the manufacturer’s recommended value) is typically required to avoid accidental shorting during soldering. [Verified] 3D Model Integration Accurate 3D models are essential for Design‑for‑Manufacturability (DFM) and Design‑for‑Assembly (DFA). They allow the manufacturer to verify component footprints, clearances, and via placement before production. The workflow for assigning 3D models involved: 1. Selecting the footprint in the sch",
    "source_file": "18_adding_silkscreen_and_final_touches.docs.md",
    "chunk_id": 1
  },
  {
    "text": "ore production. The workflow for assigning 3D models involved: 1. Selecting the footprint in the schematic and board editor. 2. Opening the 3D viewer to confirm that the component is present and correctly oriented. 3. Applying transformations—offset, rotation, and mirroring—to match the physical part. When a footprint lacked an associated 3D model, the “Missing 3D Models” report was generated. This report distinguishes between truly missing files and mis‑configured footprints, enabling targeted corrections. Using the built‑in KiCad libraries for standard parts (e.g., microphones, LEDs, polyfuses) reduces the risk of mismatched footprints. [Verified] Managing Missing 3D Models The design initially contained several components that had not yet been placed: the ESP32 module, SD card reader, U",
    "source_file": "18_adding_silkscreen_and_final_touches.docs.md",
    "chunk_id": 2
  },
  {
    "text": "ially contained several components that had not yet been placed: the ESP32 module, SD card reader, USB connector, and others. Each missing part was added sequentially, with careful attention to orientation: - Microphone : rotated to match the pin layout, then offset to align with the pad. - LEDs : identical geometry was reused for consistency, simplifying the design process. - Polyfuse : positioned with a 90° rotation to match the board’s mounting scheme. - Capacitors : 10 µF and 100 nF parts were assigned the same geometry, ensuring uniform clearance. After each addition, the 3D viewer was used to confirm that the component sat correctly on the board and that no other parts overlapped. Environmental variables were employed to resolve path issues for custom 3D models, preventing broken lin",
    "source_file": "18_adding_silkscreen_and_final_touches.docs.md",
    "chunk_id": 3
  },
  {
    "text": "ronmental variables were employed to resolve path issues for custom 3D models, preventing broken links when the project directory changes. [Verified] Path Configuration and Environmental Variables Custom 3D models were stored in a dedicated libraries/3D models directory within the project. When the project was moved or the working directory changed, the KiCad environment variables (KICAD PROJECT DIR, etc.) were updated to point to the correct location. This practice avoids broken links and ensures that the 3D viewer always references the latest files. Re‑running the “Missing 3D Models” report after updating paths confirmed that all footprints were correctly configured. [Verified] Specific Component Handling The following components required orientation adjustments to align with their datas",
    "source_file": "18_adding_silkscreen_and_final_touches.docs.md",
    "chunk_id": 4
  },
  {
    "text": "mponent Handling The following components required orientation adjustments to align with their datasheet pin‑out and the board’s mechanical layout: - Buttons : mirrored on the X‑axis and rotated 90° to fit the footprint. - USB Port : rotated 90° on the Z‑axis to match the connector orientation. - SD Card : aligned with the pad configuration; no rotation needed. - ESP32 : rotated 90° on the X‑axis to match the module’s footprint. - BME280 : flipped on the X‑axis and rotated 90° on the Z‑axis to align the reference dot. - LM117 Regulator : rotated 90° on the X‑axis to match the pin‑out. - MAX4466 Amplifier : flipped on the X‑axis to align the reference dot. - Flash Memory (W25Q32) : rotated 90° on the X‑axis. Consistent use of the same geometry for silkscreen text and component labels simpli",
    "source_file": "18_adding_silkscreen_and_final_touches.docs.md",
    "chunk_id": 5
  },
  {
    "text": "° on the X‑axis. Consistent use of the same geometry for silkscreen text and component labels simplifies the design and reduces the chance of human error. [Verified] DFM and Assembly Considerations Accurate 3D models are indispensable for assembly line automation. They allow the manufacturer to generate pick‑and‑place files that include component orientation, which is critical for high‑density boards. The design was exported from KiCad and imported into NextPCB, a commercial PCB manufacturing service. The workflow involved: - Generating a full 3D render to confirm component placement. - Exporting Gerber files and assembly data. - Submitting the design for a quote and placing an order. The final 3D render demonstrates that all components are correctly positioned, indicating readiness for ma",
    "source_file": "18_adding_silkscreen_and_final_touches.docs.md",
    "chunk_id": 6
  },
  {
    "text": "nal 3D render demonstrates that all components are correctly positioned, indicating readiness for manufacturing. [Verified] Lessons Learned and Best Practices 1. Organize 3D Models – Store custom models in a dedicated directory and reference them via project‑wide environment variables to avoid broken links when the project is moved. 2. Use the Missing 3D Models Report – Run this report after any footprint change to catch mis‑configurations early. 3. Verify Transformations – After rotating or mirroring a component, open the 3D viewer to confirm that the reference dot or pad alignment matches the datasheet. 4. Maintain Text Consistency – Reuse the same geometry for all silkscreen text to preserve readability and spacing.",
    "source_file": "18_adding_silkscreen_and_final_touches.docs.md",
    "chunk_id": 7
  },
  {
    "text": "3D Model Configuration and Visualization Overview In a modern PCB production workflow, the 3D model of the board is the bridge between design intent and manufacturability. It is used by the manufacturer to verify component placement, clearances, and mechanical constraints before the first copper layer is etched. The process described here focuses on preparing the files that feed into that 3D model—Gerbers, pick‑and‑place data, and the Bill of Materials (BOM)—and on the iterative communication that follows once the manufacturer receives them. The section also highlights common pitfalls and best‑practice recommendations that arise from real‑world experience. Gerber Preparation File Generation - Gerber files contain the copper, solder mask, silkscreen, and drill data for each layer. The trans",
    "source_file": "19_3d_model_configuration_and_visualization.docs.md",
    "chunk_id": 0
  },
  {
    "text": "- Gerber files contain the copper, solder mask, silkscreen, and drill data for each layer. The transcript confirms that the designer re‑generated Gerbers after making changes to the PCB layout. [Verified] - Zone re‑fill is performed before exporting to ensure that all copper pours are correctly defined. This step is essential for accurate copper thickness and continuity. [Verified] - Drill files (usually .drl or .txt ) are generated separately and must match the Gerber layers. The transcript notes that drill files were generated after the Gerbers. [Verified] Packaging - Manufacturers typically require the Gerber set to be zipped into a single archive. The transcript states that the files were compressed into a zip before uploading. [Verified] - The zip file should contain: - All Gerber lay",
    "source_file": "19_3d_model_configuration_and_visualization.docs.md",
    "chunk_id": 1
  },
  {
    "text": "e compressed into a zip before uploading. [Verified] - The zip file should contain: - All Gerber layers (top, bottom, inner layers, silkscreen, solder mask) - Drill files - Optional files such as a gerber.txt or readme that describe the stack‑up and layer mapping Validation - Online viewers (e.g., NextPCB’s G‑Viewer) allow a quick visual inspection of the Gerbers before submission. The transcript describes using the online viewer to confirm layer integrity. [Verified] - Design Rule Check (DRC) should be run locally to catch clearance violations, missing pads, or incomplete pours. While not explicitly mentioned, DRC is a standard step in any PCB workflow. [Inference] Pick‑and‑Place (POS) File Export - The pick‑and‑place file, often with a .pos extension, lists every component’s reference, v",
    "source_file": "19_3d_model_configuration_and_visualization.docs.md",
    "chunk_id": 2
  },
  {
    "text": " Export - The pick‑and‑place file, often with a .pos extension, lists every component’s reference, value, footprint, and XY coordinates. The transcript shows the generation of a POS file from the PCB editor. [Verified] - The file is layer‑specific : the coordinates are relative to the board’s reference plane (usually the top copper layer). This is implied by the need for accurate placement in the 3D model. [Inference] Zipping and Upload - Like Gerbers, the POS file is included in the same zip archive. The transcript confirms that the POS file was part of the upload. [Verified] Manufacturer Requirements - The manufacturer’s portal often requires the POS file to be named in a particular way (e.g., board1.pos ). The transcript does not specify a naming convention, but the file was accepted. [",
    "source_file": "19_3d_model_configuration_and_visualization.docs.md",
    "chunk_id": 3
  },
  {
    "text": ".g., board1.pos ). The transcript does not specify a naming convention, but the file was accepted. [Speculation] Bill of Materials (BOM) Required Columns Manufacturers typically ask for a BOM that contains at least the following columns: | Column | Purpose | Evidence | |--------|---------|----------| | Row designator | Identifies the board location (e.g., J1, R2) | The transcript lists “row designator” as a required field. [Verified] | | Quantity | Number of units needed | Mentioned in the transcript. [Verified] | | Manufacturer part number | Enables the manufacturer to source the exact part | The transcript shows that missing part numbers caused a revision. [Verified] | | Procurement type | Indicates whether the part is to be sourced from the manufacturer’s catalog, a third‑party, or a cu",
    "source_file": "19_3d_model_configuration_and_visualization.docs.md",
    "chunk_id": 4
  },
  {
    "text": " Indicates whether the part is to be sourced from the manufacturer’s catalog, a third‑party, or a custom supplier | The transcript references “procurement type.” [Verified] | | Customer note | Provides additional context (e.g., “use low‑profile header”) | The transcript notes a customer note field. [Verified] | Additional Fields - Row designator is often used by the manufacturer to map the component to a specific row in the 3D model. This field was explicitly requested in the transcript. [Verified] - Customer note can be used to flag special instructions (e.g., “replace J6 header with smaller version”). The transcript describes a header replacement request that was honored. [Verified] Validation - ERC/DRC should be performed on the BOM to ensure that all referenced parts exist in the layou",
    "source_file": "19_3d_model_configuration_and_visualization.docs.md",
    "chunk_id": 5
  },
  {
    "text": "tion - ERC/DRC should be performed on the BOM to ensure that all referenced parts exist in the layout and that the quantities match the design. This step is implied by the need to reconcile the BOM with the pick‑and‑place data. [Inference] Manufacturing Workflow Submission 1. Upload the zip archive containing Gerbers, drill files, and the POS file to the manufacturer’s portal. The transcript confirms this step. [Verified] 2. Select standard board thickness unless a custom stack‑up is required. The designer chose a standard thickness, which is common for cost‑effective production. [Inference] 3. Choose layer count based on signal integrity needs versus cost. While the transcript does not detail the layer count, the trade‑off is a standard consideration. [Speculation] DFM and DFA Checks - De",
    "source_file": "19_3d_model_configuration_and_visualization.docs.md",
    "chunk_id": 6
  },
  {
    "text": "il the layer count, the trade‑off is a standard consideration. [Speculation] DFM and DFA Checks - Design for Manufacturability (DFM) focuses on copper continuity, drill tolerances, and board edge tolerances. The manufacturer’s portal automatically performs DFM checks once the files are uploaded. [Inference] - Design for Assembly (DFA) concerns component clearance, pad size, and solder mask opening. The BOM and POS file are the primary inputs for DFA. [Inference] Controlled Impedance and Stack‑up - If the board contains high‑speed signals, the designer must specify a controlled impedance stack‑up and provide the necessary copper thickness and dielectric data. The transcript does not mention impedance control, but it is a typical requirement for 3D model verification. [Speculation] Communica",
    "source_file": "19_3d_model_configuration_and_visualization.docs.md",
    "chunk_id": 7
  },
  {
    "text": "mpedance control, but it is a typical requirement for 3D model verification. [Speculation] Communication with Engineers Initial Review - After file submission, the manufacturer’s engineering team reviews the 3D model and sends a confirmation request . The transcript describes a confirmation email with images of the assembled board. [Verified] Common Issues | Issue | Resolution | Evidence | |-------|------------|----------| | Missing manufacturer part numbers | Update BOM with part numbers and resubmit | The transcript shows a BOM revision after missing part numbers were identified. [Verified] | | Ambiguous capacitor polarity | Clarify symbol conventions (dot = anode, bracket = cathode) | The transcript explains how the manufacturer resolved the confusion. [Verified] | | Diode cathode ident",
    "source_file": "19_3d_model_configuration_and_visualization.docs.md",
    "chunk_id": 8
  },
  {
    "text": " transcript explains how the manufacturer resolved the confusion. [Verified] | | Diode cathode identification | Use the bracket silk‑screen indicator | The transcript details the use of a blue bracket graphic to denote cathodes. [Verified] | | Header size mismatch | Replace with a smaller header to facilitate testing | The transcript mentions a header replacement request that was accepted. [Verified] | Iterative Feedback Loop - The manufacturer’s portal often provides a change request",
    "source_file": "19_3d_model_configuration_and_visualization.docs.md",
    "chunk_id": 9
  },
  {
    "text": "Preparing Files for Manufacturing Overview The transition from a finished schematic and layout to a set of files that a PCB manufacturer can process is a critical phase in the design cycle. It is the point where design intent is translated into a tangible product, and any oversight can lead to costly re‑runs or, worse, a non‑functional board. The process involves a disciplined application of design‑rule checks, careful stack‑up definition, controlled‑impedance management, and the generation of a complete set of manufacturing and assembly documentation. The following sections outline the key concepts, decisions, and best‑practice guidelines that underpin a robust file‑preparation workflow. Design Verification and Rule Checks Before any files are exported, the design must satisfy all electri",
    "source_file": "20_preparing_files_for_manufacturing.docs.md",
    "chunk_id": 0
  },
  {
    "text": "sign Verification and Rule Checks Before any files are exported, the design must satisfy all electrical and mechanical constraints. This is typically achieved through a combination of ERC (Electrical Rule Check) and DRC (Design Rule Check) . ERC verifies that the schematic is logically sound—no floating nets, no missing connections, and correct component footprints. DRC ensures that the layout respects spacing, clearance, and trace width rules defined for the target manufacturer. In addition to these automated checks, a manual review of critical nets (high‑speed signals, power planes, ground references) is essential to catch subtle issues that rule engines may miss. [Verified] KiCad 9 Features and Workflow KiCad 9 introduces several enhancements that streamline the file‑preparation stage. ",
    "source_file": "20_preparing_files_for_manufacturing.docs.md",
    "chunk_id": 1
  },
  {
    "text": "es and Workflow KiCad 9 introduces several enhancements that streamline the file‑preparation stage. The updated Eeschema and Pcbnew modules provide more intuitive footprint libraries, improved netlist handling, and tighter integration with the KiCad 9 Design Rule Checker . The ability to import and export KiCad 9 RC (Release Candidate) files allows designers to test new features before they become stable, ensuring that the final design benefits from the latest bug fixes and performance improvements. [Verified] PCB Stackup and Layer Management A well‑defined stackup is the foundation of any high‑quality PCB. For a four‑layer IoT board, the typical arrangement is: 1. Top Layer – Signal traces and component pads. 2. Inner Layer 1 – Ground plane. 3. Inner Layer 2 – Power plane. 4. Bottom Layer",
    "source_file": "20_preparing_files_for_manufacturing.docs.md",
    "chunk_id": 2
  },
  {
    "text": "and component pads. 2. Inner Layer 1 – Ground plane. 3. Inner Layer 2 – Power plane. 4. Bottom Layer – Signal traces and component pads. This configuration offers a good balance between cost and performance: the inner planes provide low‑impedance reference planes for signal integrity, while the outer layers accommodate component placement and routing flexibility. The choice of dielectric thickness, copper weight, and layer sequence directly influences impedance control, thermal performance, and manufacturability. [Inference] Controlled Impedance and Signal Integrity High‑speed signals (e.g., USB, Ethernet, or RF interfaces) require careful impedance matching to avoid reflections and signal loss. In a four‑layer stackup, the trace width and spacing to the nearest reference plane determine t",
    "source_file": "20_preparing_files_for_manufacturing.docs.md",
    "chunk_id": 3
  },
  {
    "text": "oss. In a four‑layer stackup, the trace width and spacing to the nearest reference plane determine the characteristic impedance. Designers should use the manufacturer’s impedance calculator or a dedicated tool to verify that the trace dimensions meet the required tolerance (typically ±5 % for most protocols). Additionally, differential pairs should be routed with matched lengths and minimal skew; the use of microvias or blind/buried vias can help maintain symmetry while preserving board density. [Inference] DFM and DFA Considerations Design for Manufacturability (DFM) and Design for Assembly (DFA) principles guide many layout decisions: - Via density : Excessive via usage can increase cost and reduce yield. - Pad size and spacing : Must accommodate the manufacturer’s pick‑and‑place toleran",
    "source_file": "20_preparing_files_for_manufacturing.docs.md",
    "chunk_id": 4
  },
  {
    "text": "nd reduce yield. - Pad size and spacing : Must accommodate the manufacturer’s pick‑and‑place tolerances. - Component placement : Avoiding tight clusters near high‑frequency nets reduces EMI. - Thermal relief : Ensures that pads can be soldered without overheating the board. Incorporating a DFM checklist early in the design process helps catch potential issues before the board is fabricated. [Verified] Gerber and Drill File Generation The Gerber format remains the industry standard for conveying copper, solder mask, and silkscreen layers. When exporting Gerbers: - Layer naming : Follow the manufacturer’s naming convention (e.g., TopCopper.gbr, BottomSilkscreen.gbr). - Units and precision : Use millimeters with a precision of at least 0.001 mm. - Format : Exclude the - sign in the file names",
    "source_file": "20_preparing_files_for_manufacturing.docs.md",
    "chunk_id": 5
  },
  {
    "text": "e millimeters with a precision of at least 0.001 mm. - Format : Exclude the - sign in the file names if the manufacturer requires it. - Drill files : Generate a separate drill file (Excellon or ODB++) that lists all hole coordinates, diameters, and tolerances. It is prudent to run a Gerber viewer (e.g., KiCad’s built‑in viewer or a third‑party tool) to verify that all layers align correctly and that no traces are inadvertently omitted. [Verified] BOM and Pick‑and‑Place A clean Bill of Materials (BOM) is essential for assembly. Each component entry should include: - Reference designator - Value and package type - Manufacturer part number - Quantity The pick‑and‑place file (usually in CSV or ODB++ format) must provide the X/Y coordinates, rotation, and side (top/bottom) for every component. ",
    "source_file": "20_preparing_files_for_manufacturing.docs.md",
    "chunk_id": 6
  },
  {
    "text": "DB++ format) must provide the X/Y coordinates, rotation, and side (top/bottom) for every component. Consistency between the BOM and the pick‑and‑place file prevents mis‑placement and reduces assembly errors. [Verified] Assembly Drawings and Documentation Manufacturers often require assembly drawings that illustrate component orientation, solder paste stencil dimensions, and any special handling instructions. These drawings should be generated from the layout file and exported as PDFs or vector graphics. Including a solder paste stencil file (e.g., Gerber or ODB++ stencil layer) is also recommended for automated pick‑and‑place lines. [Verified] Common Pitfalls and Lessons Learned - Missing or mismatched footprints : Always verify that the footprint library matches the schematic netlist. - U",
    "source_file": "20_preparing_files_for_manufacturing.docs.md",
    "chunk_id": 7
  },
  {
    "text": " mismatched footprints : Always verify that the footprint library matches the schematic netlist. - Unintentional via stitching : While stitching can improve EMI, excessive stitching may create short circuits if not carefully routed. - Incorrect layer assignment : A mis‑assigned trace can lead to signal integrity problems or even board failure. - Overlooking clearance rules : High‑voltage or high‑frequency nets require stricter clearance to avoid arcing or crosstalk. Addressing these issues early through rigorous DRC/ERC and manual review saves time and money in the long run. [Inference] Conclusion Preparing files for manufacturing is a multi‑faceted task that blends rigorous rule checking, thoughtful stackup design, and meticulous documentation. By leveraging the latest features of KiCad 9",
    "source_file": "20_preparing_files_for_manufacturing.docs.md",
    "chunk_id": 8
  },
  {
    "text": "houghtful stackup design, and meticulous documentation. By leveraging the latest features of KiCad 9, adhering to DFM/DFA guidelines, and generating clean, manufacturer‑ready files, designers can ensure a smooth transition from concept to production. The disciplined approach outlined above not only reduces the risk of costly re‑runs but also enhances the reliability and performance of the final product.",
    "source_file": "20_preparing_files_for_manufacturing.docs.md",
    "chunk_id": 9
  },
  {
    "text": "Conclusion and Next Steps Final Design Review After the board has been fabricated, the first critical activity is a thorough visual inspection. Verify that all component footprints match the bill of materials, that solder mask coverage is complete, and that no unintended solder bridges or voids are present. This inspection should be performed by a qualified technician using a magnification tool or an automated optical inspection system. The goal is to catch any manufacturing defects before the board is populated or tested. [Verified] Post‑Manufacturing Testing Once the board passes visual inspection, a structured test plan should be executed. Begin with a continuity and isolation check to confirm that all traces are correctly routed and that there are no short circuits between adjacent lay",
    "source_file": "21_conclusion_and_next_steps.docs.md",
    "chunk_id": 0
  },
  {
    "text": "nfirm that all traces are correctly routed and that there are no short circuits between adjacent layers or components. Follow this with an electrical rule check (ERC) verification against the design intent, ensuring that all net connections are correct and that no floating nets remain. Finally, perform functional testing of the circuit under its intended operating conditions. This may involve applying power, driving input signals, and measuring output responses to confirm that the board behaves as designed. [Verified] Feedback Loop and Iteration The manufacturing and testing phase often reveals subtle issues that were not apparent during simulation or design review. Document any anomalies, trace their root causes, and update the design files accordingly. If a design change is required, re‑",
    "source_file": "21_conclusion_and_next_steps.docs.md",
    "chunk_id": 1
  },
  {
    "text": "race their root causes, and update the design files accordingly. If a design change is required, re‑run the design rule checks and update the manufacturing data before sending the board back to the fab. This iterative cycle—design, fabricate, test, refine—is essential for achieving a robust final product. [Inference] Documentation and Archiving Maintain a complete set of design files, including the schematic, layout, Gerber files, drill data, and BOM. Store these in a version‑controlled repository so that future revisions can be tracked and audited. Include a manufacturing report that summarizes the inspection and test results, and attach any relevant photos or test logs. Proper documentation not only aids in troubleshooting but also facilitates compliance with industry standards such as I",
    "source_file": "21_conclusion_and_next_steps.docs.md",
    "chunk_id": 2
  },
  {
    "text": "n not only aids in troubleshooting but also facilitates compliance with industry standards such as IPC‑2221 and IPC‑7351. [Verified] Future Enhancements With a working prototype in hand, consider opportunities for performance or cost improvements. For example, if the board uses a high‑layer stackup, evaluate whether a reduced‑layer design could meet the same impedance and thermal requirements at lower cost. Alternatively, if the board is intended for mass production, explore the use of a more advanced surface‑mount process or a different solder paste formulation to improve yield. These decisions should be guided by a cost‑benefit analysis that weighs manufacturing complexity against the desired performance envelope. [Speculation] Summary of Key Lessons - Design for Manufacturability (DFM) ",
    "source_file": "21_conclusion_and_next_steps.docs.md",
    "chunk_id": 3
  },
  {
    "text": "red performance envelope. [Speculation] Summary of Key Lessons - Design for Manufacturability (DFM) : Early consideration of DFM constraints—such as minimum trace width, via size, and pad spacing—reduces the risk of costly re‑runs. [Verified] - Design for Assembly (DFA) : Simplifying component placement, using standard footprints, and providing clear assembly instructions streamline the pick‑and‑place process. [Verified] - Controlled Impedance and Stackup : When high‑speed signals are present, a carefully engineered stackup with reference planes and matched trace lengths is essential to maintain signal integrity. [Verified] - Electrical Rule Check (ERC) and Design Rule Check (DRC) : Automated checks catch many errors before fabrication, but a manual review of critical nets and high‑power t",
    "source_file": "21_conclusion_and_next_steps.docs.md",
    "chunk_id": 4
  },
  {
    "text": "d checks catch many errors before fabrication, but a manual review of critical nets and high‑power traces remains indispensable. [Verified] - Testing and Validation : A structured test plan that covers continuity, isolation, and functional performance ensures that the board meets its specifications before it reaches the end user. [Verified] By following these practices and maintaining a disciplined feedback loop, the transition from design to a reliable, manufacturable product becomes a predictable and repeatable process.",
    "source_file": "21_conclusion_and_next_steps.docs.md",
    "chunk_id": 5
  },
  {
    "text": "KICAD LIKE A PRO, THIRD EDITION KiCad Like a Pro, 3rd Edition By Dr Peter Dalmaris Copyright © 2021 by Tech ExplorationsTM All rights reserved. This book or any portion thereof may not be reproduced or used in any manner whatsoever without the express written permission of the publisher except for the use of brief quotations in a book review. Printed in Australia First Printing, 2018 ISBN (PDF) : 978-1-68489-093-4 ISBN (epub): 978-1-68489-094-1 ISBN (mobi): 978-1-68489-089-7 Tech Explorations Publishing PO Box 22, Berowra 2081 NSW Australia www.techexplorations.com Cover designer: Michelle Dalmaris Disclaimer The material in this publication is of the nature of general comment only, and does not represent professional advice. It is not intended to provide speciﬁc guidance for particular ci",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 0
  },
  {
    "text": " not represent professional advice. It is not intended to provide speciﬁc guidance for particular circumstances and it should not be relied on as the basis for any decision to take action or not take action on any matter which it covers. Readers should obtain professional advice where appropriate, before making any such decision. To the maximum extent permitted by law, the author and publisher disclaim all responsibility and liability to any person, arising directly or indirectly from any person taking or not taking action based on the information in this publication. Version 1 Did you ﬁnd an error? Please let us know. Using any web browser, go to txplo.re/kicadr, and ﬁll in the form. We’ll get it ﬁxed right away. About the author Dr. Peter Dalmaris is an educator, an electrical engineer, ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 1
  },
  {
    "text": "get it ﬁxed right away. About the author Dr. Peter Dalmaris is an educator, an electrical engineer, electronics hobbyist, and Maker. Creator of online video courses on DIY electronics and author of several technical books. Peter has recently released his book 'Maker Education Revolution', a book about how Making is changing the way we learn and teach in the 21st century. As a Chief Tech Explorer since 2013 at Tech Explorations, the company he founded in Sydney, Australia, Peter’s mission is to explore technology and help educate the world. Tech Explorations offers educational courses and Bootcamps for electronics hobbyists, STEM students, and STEM teachers. A lifelong learner, Peter’s core skill lies in explaining difﬁcult concepts through video and text. With over 15 years of tertiary tea",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 2
  },
  {
    "text": "kill lies in explaining difﬁcult concepts through video and text. With over 15 years of tertiary teaching experience, Peter has developed a simple yet comprehensive style in teaching that students from all around the world appreciate. His passion for technology and the world of DIY open-source hardware, has been a dominant driver that has guided his personal development and his work through Tech Explorations. About Tech Explorations Tech Explorations creates educational products for students and hobbyists of electronics who rather utilize their time making awesome gadgets instead of searching endlessly through blog posts and Youtube videos. We deliver high-quality instructional videos and books through our online learning platform, txplore.com. Supporting our students through their learnin",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 3
  },
  {
    "text": "oks through our online learning platform, txplore.com. Supporting our students through their learning journey is our priority, and we do this through our dedicated online community and course forums. Founded in 2013 by Peter Dalmaris, Tech Explorations was created after Peter realised how difﬁcult it was to ﬁnd high-quality deﬁnitive guides for the Arduino, written or produced by creators who responded to their reader questions. Peter was frustrated having to search for Youtube videos and blog articles that almost never seemed to be made for the purpose of conveying knowledge. He decided to create Teach Explorations so that he could produce the educational content that he wished he could ﬁnd back then. Tech Explorations courses are designed to be comprehensive, deﬁnitive and practical. Whe",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 4
  },
  {
    "text": " back then. Tech Explorations courses are designed to be comprehensive, deﬁnitive and practical. Whether it is through video, ebook, blog or email, our delivery is personal and conversational. It is like having a friend showing you something neat... the \"AHA\" moments just ﬂow! Peter left his career in Academia after his passion for electronics and making was rekindled with the arrival of his ﬁrst Arduino. Although he was an electronics hobbyist from a young age, something the led him to study electrical and electronics engineering in University, the Arduino signalled a revolution in the way that electronics is taught and learned. Peter decided to be a part of this revolution and has never looked back. We know that even today, with all the information of the world at your ﬁngertips, thanks ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 5
  },
  {
    "text": "oked back. We know that even today, with all the information of the world at your ﬁngertips, thanks to Google, and all the components of the world one click away, thanks to eBay, the life of the electronics hobbyist is not easy. Busy lifestyles leave little time for your hobby, and you want this time to count. We want to help you to enjoy your hobby. We want you to enjoy learning amazing practical things that you can use to make your own awesome gadgets. Electronics is a rewarding hobby. Science, engineering, mathematics, art, and curiosity all converge in a tiny circuit with a handful of components. We want to help you take this journey without delays and frustrations. Our courses have been used by over 70,000 people across the world. From prototyping electronics with the Arduino to learn",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 6
  },
  {
    "text": " used by over 70,000 people across the world. From prototyping electronics with the Arduino to learning full-stack development with the Raspberry Pi or designing professional-looking printed circuit boards for their awesome gadgets, our students enjoyed taking our courses and improved their making skills dramatically. Here's what some of them had to say: \"I'm about half way through this course and I am learning so much. Peter is an outstanding instructor. I recommend this course if you really want to learn about the versatility of the amazing Raspberry Pi\" -- Scott \"The objectives of this course are uniquely deﬁned and very useful. The instructor explains the material very clearly.\" -- Huan \"Logical for the beginner. Many things that I did not know so far about Arduino but easy to understa",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 7
  },
  {
    "text": "\"Logical for the beginner. Many things that I did not know so far about Arduino but easy to understand. Also the voice is easy to understand which is unlike many courses about microcontrollers that I have STARTED in the past. Thanks\" -- Anthony Please check out our courses at techexplorations.com and let us be part of your tech adventures. From the back cover Printed circuit boards (PCBs) are, perhaps, the most undervalued component of modern electronics. Usually made of ﬁbreglass, PCBs are responsible for holding in place and interconnecting the various components that make virtually all electronic devices work. The design of complex printed circuit boards was something that only skilled engineers could do. These engineers used expensive computer-aided design tools. The boards they design",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 8
  },
  {
    "text": "gineers could do. These engineers used expensive computer-aided design tools. The boards they designed were manufactured in exclusive manufacturing facilities in large numbers. Not anymore. During the last 20 years, we have seen high-end engineering capabilities becoming available to virtually anyone that wants them. Computer-aided design tools and manufacturing facilities for PCBs are one mouse click away. KiCad is one of those tools. Perhaps the world’s most popular (and best) computer-aided design tool for making printed circuit boards, KiCad is open source, fully featured, well-funded and supported, well documented. It is the perfect tool for electronics engineers and hobbyists alike, used to create amazing PCBs. KiCad has reached maturity and is now a fully featured and stable choice ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 9
  },
  {
    "text": "ed to create amazing PCBs. KiCad has reached maturity and is now a fully featured and stable choice for anyone that needs to design custom PCBs. This book will teach you to use KiCad. Whether you are a hobbyist or an electronics engineer, this book will help you become productive quickly, and start designing your own boards. Are you a hobbyist? Is the breadboard a bottleneck in your projects? Do you want to become skilled in circuit board design? If yes, then KiCad and this book are a perfect choice. Use KiCad to design custom boards for your projects. Don’t leave your projects on the breadboard, gathering dust and falling apart. Complete your prototyping process with a beautiful PCB and give your projects a high-quality, professional look. Are you an electronics engineer? Perhaps you alre",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 10
  },
  {
    "text": "e your projects a high-quality, professional look. Are you an electronics engineer? Perhaps you already use a CAD tool for PCB design. Are you interested in learning KiCad and experience the power and freedom of open-source software? If yes, then this book will help you become productive with KiCad very quickly. You can build on your existing PCB design knowledge and learn KiCad through hands-on projects. This book takes a practical approach to learning. It consists of four projects of incremental difﬁculty and recipes. The projects will teach you basic and advanced features of KiCad. If you have absolutely no prior knowledge of PCB design, you will ﬁnd that the introductory project will teach you the very basics. You can then continue with the rest of the projects. You will design a board",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 11
  },
  {
    "text": "ch you the very basics. You can then continue with the rest of the projects. You will design a board for a breadboard power supply, a tiny Raspberry Pi HAT, and an Arduino clone with extended memory and clock integrated circuits. The book includes a variety of recipes for frequently used activities. You can use this part as a quick reference at any time. The book is supported by the author via a page that provides access to additional resources. Signup to receive assistance and updates. How to read this book I designed this book to be used both to learn how to use KiCad, and as a reference. All examples, descriptions and procedures are tested on the nightly releases of KiCad 6 (also known as KiCad 5.99) and in KiCad 6 RC1. If you have never used KiCad and have little or no experience in PC",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 12
  },
  {
    "text": " KiCad 5.99) and in KiCad 6 RC1. If you have never used KiCad and have little or no experience in PCB design, I recommend you read it in a linear fashion. Don’t skip the early chapters in parts 1 to 8 because those will give you the fundamental knowledge on which you will build your skill later in the book. If you skip those chapters, you will have gaps in your knowledge that will make it harder for you to progress. If you have a good working knowledge of PCB design, but you are new to KiCad, you can go straight to Parts 7 and 8, zoom through them quickly, and then proceed to the projects in Part 9. Once you have the basic KiCad concepts and skills conﬁdently learned, you can use the recipes in Parts 7, 8 and 13 as a resource for speciﬁc problems you need solved. These recipes are useful o",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 13
  },
  {
    "text": " in Parts 7, 8 and 13 as a resource for speciﬁc problems you need solved. These recipes are useful on their own. Throughout the text, you will also ﬁnd prompts to go to a particular recipe in order to learn a speciﬁc skill needed for the projects. Throughout this book, you will ﬁnd numerous ﬁgures that contain screenshots of KiCad. To create these screenshots, I used KiCad 5.99 and KiCad 6.0 RC1 running on Mac OS. If you are using KiCad under Windows or Linux, do not worry: KiCad works the same across these platforms, and even looks almost the same. Although I took care to produce images that are clear, there are cases where this was not possible. This is particularly true in screenshots of an entire application window, meant to be displayed in a large screen. The role of these images is t",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 14
  },
  {
    "text": "an entire application window, meant to be displayed in a large screen. The role of these images is to help you follow the instructions in the book as you are working on your computer. There is no substitute to experimenting and learning by doing, so the best advice I can give is to use this book as a text book and companion. Whenever you read it, have KiCad open on your computer and follow along with the instructions. This book has a web page with resources designed to maximize the value it delivers to you, the reader. Please read about the book web page, what it offers and how to access it in the section 'The book web page', later in this introductory segment. 1 Finally, you may be interested in the video course version of this book. This course spans over 25 hours of high-deﬁnition video",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 15
  },
  {
    "text": "ed in the video course version of this book. This course spans over 25 hours of high-deﬁnition video, with detailed explanations and demonstrations of all projects featured in the book. The video lectures capture techniques and procedures that are just not possible to do so in text. Please check in the book web page for updates on this project. Be sure to subscribe to the Tech Explorations email list so I can send you updates. 2 Requirements To make the most out of this book, you will need a few things. You probably already have them: • A computer running Windows, Mac OS or Linux. • Access to the Internet. • A mouse with at least two buttons and a scroll wheel. I use a Logitech MX Master 2S mouse (see https://amzn.to/2ClySq0). • Ability to install software. • Time to work on the book, and ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 16
  },
  {
    "text": "mouse (see https://amzn.to/2ClySq0). • Ability to install software. • Time to work on the book, and patience. 3 The book web page As a reader of this book, you are entitled access to its online resources. You can access these resources by visiting the book’s web page at txplo.re/kicadr. The two available resources are: 1. Photos and schematics. Get high-res copies of the photos, schematics, and layouts that appear in the book. 2. An errata page. As I correct bugs, I will be posting information about these corrections in this page. Please check this page if you suspect that you have found an error. If an error you have found is not listed in the errata page, please use the error report form in the same page to let me know about it. 4 Why all the ?? in the TOC? The version of the book you ar",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 17
  },
  {
    "text": "n the same page to let me know about it. 4 Why all the ?? in the TOC? The version of the book you are looking at is the video course companion. This version of the book contains speciﬁc chapters from the full book - not all of them. For this reason, any chapter from the full book that is not available in this companion is marked with “??” Instead of an actual page number in the Table of Contents. All the pages and chapters from the full book that are present in the companion book will have the actual page number correctly listed in the TOC. 5 Table of Contents Introduction 1. What is a PCB? 2. The PCB design process 3. Fabrication 4. Get KiCad for your operating system 5. Example KiCad projects Part 2: Getting started with KiCad 6 1. Introduction 2. KiCad Project Manager (main window) 3. O",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 18
  },
  {
    "text": "cts Part 2: Getting started with KiCad 6 1. Introduction 2. KiCad Project Manager (main window) 3. Overview of the individual KiCad apps 4. Paths and Libraries 5. Create a new project from scratch 6. Create a new project from a template 7. KiCad 6 on Mac OS, Linux, Windows 8. Differences between KiCad 6 and 5 Part 3: Project - A hands-on tour of KiCad - Schematic Design 1. Introduction to schematic design and objective of this section Design workﬂows summary The ﬁnished KiCad project and directory Start Kicad and create a new project 1 - Start Eeschema, setup Sheet 2 - Add symbols 3 - Arrange, annotate, associate 4 - Wiring 5 - Nets 6 - The Electrical Rules Check 7 - Comments with text and graphics Part 4: Project- A hands-on tour of KiCad - Layout 1. Introduction to layout design and obje",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 19
  },
  {
    "text": "raphics Part 4: Project- A hands-on tour of KiCad - Layout 1. Introduction to layout design and objective of this section 1 - Start Pcbnew, import footprints 2 - Outline and constraints (edge cut) 3 - Move footprints in place 4 - Route (add tracks) 5 - Reﬁne the outline 6 - Silkscreen (text and graphics) 6 29 30 36 41 43 47 56 57 58 64 72 76 78 82 87 89 90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 93 94 ?? ?? ?? ?? ?? ?? 7 - Design rules check 8 - Export Gerbers and order The manufactured PCB Part 5: Design principles and PCB terms Introduction Schematic symbols PCB key terms FR4 Traces Pads and holes Via Annular ring Soldermask Silkscreen Drill bit and drill hit Surface mounted devices Gold Fingers Keep-out areas Panel Solder paste and paste stencil Pick-and-place Part 6: PCB design workﬂows The KiCa",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 20
  },
  {
    "text": "p-out areas Panel Solder paste and paste stencil Pick-and-place Part 6: PCB design workﬂows The KiCad Schematic Design Workﬂow Schematic Design Step 1: Setup Schematic Design Step 2: Symbols Schematic Design Step 3: AAA (Arrange, Annotate, Associate) Schematic Design Step 4: Wire Schematic Design Step 5: Nets Schematic Design Step 6: Electrical Rules Check Schematic Design Step 7: Comments and Graphics The KiCad Layout Design Workﬂow Layout Design Step 1: Setup Layout Design Step 2: Outline and constraints Layout Design Step 3: Place footprints Layout Design Step 4a: Route Layout Design Step 4b: Copper ﬁlls Layout Design Step 5: Silkscreen Layout Design Step 6: Design rules check 7 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 21
  },
  {
    "text": "?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? Layout Design Step 7: Export & Manufacture Part 7: Fundamental Kicad how-to: Symbols and Eeschema Introduction Left menu bar overview Top menu bar overview Right menu bar overview Schematic editor preferences How to ﬁnd a symbol with the Chooser How to ﬁnd schematic symbols on the Internet How to install symbol libraries in bulk How to create a custom symbol How to associate a symbol with a footprint Net labels Net classes Hierarchical sheets Global labels Hierarchical labels and import sheet pin Electrical rules and customization Bulk editing of schematic elements Part 8: Fundamental Kicad how-to: Footprints and Pcbnew Introduction Left toolbar Top toolbar Top toolbar Row 1 Top toolbar",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 22
  },
  {
    "text": "ad how-to: Footprints and Pcbnew Introduction Left toolbar Top toolbar Top toolbar Row 1 Top toolbar Row 2 Right toolbar Right toolbar main buttons Right toolbar - Appearance Layout editor preferences Board Setup Board Setup - Board Stackup Board Setup - Text & Graphics Board Setup - Design Rules and net classes Board Setup - Design Rules - Custom Rules and violation severity How to ﬁnd and use a footprint Footprint sources on the Internet How to install footprint libraries Filled zones 8 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? Keep-out zones Interactive router Length measuring tools Bulk editing Create a custom footprint, introduction Create a new library and footprint Create a footprint, 1, Fabrication layer Create",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 23
  },
  {
    "text": "int, introduction Create a new library and footprint Create a footprint, 1, Fabrication layer Create a footprint, 2, Pads Create a footprint, 3, Courtyard layer Create a footprint, 4, Silkscreen layer Use the new footprint Finding and using a 3D shape for a footprint How to export and test Gerber ﬁles Part 9: Project - Design a simple breadboard power supply PCB 1. Introduction Schematic design editing 1 - Setup 2 - Symbols 2 - Edit Component values 3 - Arrange, Annotate 3 - Associate 4 - Wiring 5 & 6 - Nets and Electrical Rules Check 7 - Comments Layout design editing 1 - Setup 2 - Outline and constraints 3 - Place footprints 2 - Reﬁne the outline 4 - Route 5 - Copper ﬁlls 6 - Silkscreen 7 - Design Rules Check 8 - Export and Manufacture Part 10: Project - A 4 x 8 x 8 LED matrix array 1. I",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 24
  },
  {
    "text": "- Design Rules Check 8 - Export and Manufacture Part 10: Project - A 4 x 8 x 8 LED matrix array 1. Introduction Schematic design 1 - Setup 9 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 96 97 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 102 103 ?? Schematic design Schema 1 - Setup Schema 2 - Symbols Schema 3 - Arrange, Annotate Schema 3 - Associate Schema 4 - Wiring Schema 5 - Nets Schema 6 - Electrical Rules Check Schema 7 - Comments Schema - Last-minute edits Layout design Layout 1 - Setup Layout 2 - Outline and constraints Layout 3 - Place components Layout 2 supplemental - Reﬁne outline Layout 3 supplemental - Move footprints to back layer Layout 4 - Route Layout 4 - Copper ﬁlls Layout 5 - Silkscreen Layout 6 - Design Rules Check Layout 7 - Manufacture Bonus - 3D shapes Bonus - F",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 25
  },
  {
    "text": "yout 5 - Silkscreen Layout 6 - Design Rules Check Layout 7 - Manufacture Bonus - 3D shapes Bonus - Found a bug in the schematic! (and ﬁx) The assembled and working PCB 2 - Symbols 3 - Arrange, Annotate 3 - Associate 4 - Wiring 5 - Nets 6 - Electrical Rules Check 7 - Comments Last-minute edits Layout design editing 1 - Setup 2 - Outline and constraints 3 - Place components 2 - Reﬁne outline 3 - Move footprints 10 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 4 - Route 4 - Copper ﬁlls 5 - Silkscreen 6 - Design Rules Check 7 - Manufacture Bonus - 3D shapes Bonus - Found a bug in the schematic! (and ﬁx) Bonus - 3D shapes Bonus - Found a bug in the schematic! (and ﬁx) The assembled and working PCBThe assembled and working PCB Bonus - Found a bug in the schematic! (and ﬁx) The assembled and worki",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 26
  },
  {
    "text": "The assembled and working PCB Bonus - Found a bug in the schematic! (and ﬁx) The assembled and working PCBSchematic design Schema 1 - Setup Schema 2 - Symbols Schema 3 - Arrange, Annotate Schema 3 - Associate Schema 4 - Wiring Schema 5 - Nets Schema 6 - Electrical Rules Check Schema 7 - Comments Schema - Last-minute edits Layout design Layout 1 - Setup Layout 2 - Outline and constraints Layout 3 - Place components Layout 2 supplemental - Reﬁne outline Layout 3 supplemental - Move footprints to back layer Layout 4 - Route Layout 4 - Copper ﬁlls Layout 5 - Silkscreen Layout 6 - Design Rules Check Layout 7 - Manufacture Bonus - 3D shapes Bonus - Found a bug in the schematic! (and ﬁx) The assembled and working PCB Part 11 : Project - MCU datalogger 1. Project - Introduction Create the new proj",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 27
  },
  {
    "text": "led and working PCB Part 11 : Project - MCU datalogger 1. Project - Introduction Create the new project and Git repository 11 ?? ?? ?? ?? ?? ?? ?? ?? 108 109 ?? Schematic design Schema 1 - Setup Schema 2 - Symbols Schema 2 - Sheet two Schema 3 - Arrange, Annotate Edit component values Schema 3 - Associate Schema 4 - Wiring of sheet 1 Schema 4 - Wiring of sheet 2 Schema 5 - Nets Schema 6 - Electrical Rules Check Schema 7 - Comments Create the 2-layer branch in Git Layout design Layout 1 - Setup Layout 2 - Outline and constraints Layout 3 - Place components Layout 2 - Outline reﬁnement Layout 4 - Route Layout 4 - Copper ﬁlls Layout 4 - Routing improvements Layout 5 - Silkscreen Layout 4 - Routing violations and complete silkscreen Layout 6 - Design Rules Check Layout 7 - Manufacture 3D shape",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 28
  },
  {
    "text": "ing violations and complete silkscreen Layout 6 - Design Rules Check Layout 7 - Manufacture 3D shapes Merge 2-layer branch to main Design 4 Layer PCB in new Git branch Four-layer PCB routing Four-layer PCB manufacturing Updating layout from changes to the schematic with Git Part 12 : Project - An ESP32 clone 1. Project - Introduction Schematic design Schema 1 - New KiCad project and Schematic Setup Schema 2 - Symbols Schema 3 - Annotate and set component values Schema 3 - Arrange 12 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 113 ?? ?? ?? ?? ?? Schema 3 - Associate Schema 4 - Wiring Schema 5 - Nets and Net Classes Schema 6 - Electrical Rules Check Schema 7 - Comments Layout design Layout 1 - Setup Layout 2 - Outline and constraints Layout",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 29
  },
  {
    "text": "s Check Schema 7 - Comments Layout design Layout 1 - Setup Layout 2 - Outline and constraints Layout 3 - Place components Layout 2 supplemental - reﬁne outline Layout 4 - Route Layout 4 - Copper ﬁlls and keep out areas Layout 5 - Silkscreen Layout 4 - Routing improvements Layout 6 - Design Rules Check Layout 7 - Manufacture 3D shapes Part 13: Recipies Create a custom silkscreen or copper graphic Change a symbols and footprints in bulk Change a symbol in bulk Change a footprint in bulk Interactive delete Find and Replace (Eeschema) Edit Text & Graphics Properties Edit Track & Via Properties (Pcbnew) Text variables Board Setup - pre-deﬁned sizes for tracks and vias Board Setup - Design rules violation severity Board Setup - Custom design rules Schematic Setup - Electrical Rules and violation",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 30
  },
  {
    "text": "iolation severity Board Setup - Custom design rules Schematic Setup - Electrical Rules and violation severity Schematic Setup - Electrical Rules and Pin conﬂicts map Field name templates Bill of Materials Build-in BOM in Pcbnew Build-in BOM in Eeschema A plug-in for BOM Import components from Snapeda 13 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? The Freerouting autorouter Install and start FreeRouting on MacOS Install and start FreeRouting on Linux Kubuntu Install and start FreeRouting on Windows How to use the Freerouting autorouter 2-layer example How to use the Freerouting autorouter 4-layer example Pcbnew Inspection menu Single track and differential pair routing Track length tuning Differential pair skew tuning Int",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 31
  },
  {
    "text": "enu Single track and differential pair routing Track length tuning Differential pair skew tuning Interactive router modes The footprint wizard Pin and wire highlighter tool Pcbnew Origins KiCad project management with Git Install Git Git conﬁguration Create a new KiCad project Git repository How to ignore ﬁles Basic Git commands: add, commit Basic Git commands: branch Basic Git commands: merge Sharing your KiCad project on GitHub Customize the editor color scheme Import an EAGLE, Altium, or Cadstar project The circuit simulator Prepare the circuit for simulation Conﬁgure the simulator Simulate Import a KiCad 5 project KiCad project templates Using a system project template Create a user project template Archive/unarchive and share a project Buses Calculate the width of a trace Design a cus",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 32
  },
  {
    "text": "ect template Archive/unarchive and share a project Buses Calculate the width of a trace Design a custom schematic sheet 14 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? Detailed Table of Contents Introduction 1. What is a PCB? 2. The PCB design process 3. Fabrication 4. Get KiCad for your operating system 5. Example KiCad projects Part 2: Getting started with KiCad 6 1. Introduction 2. KiCad Project Manager (main window) 3. Overview of the individual KiCad apps 4. Paths and Libraries 5. Create a new project from scratch 6. Create a new project from a template 7. KiCad 6 on Mac OS, Linux, Windows 8. Differences between KiCad 6 and 5 Part 3: Project - A hands-on tour of KiCad - Schematic Design 1. Introduction to schematic desi",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 33
  },
  {
    "text": "nd 5 Part 3: Project - A hands-on tour of KiCad - Schematic Design 1. Introduction to schematic design and objective of this section Design workﬂows summary The ﬁnished KiCad project and directory Start Kicad and create a new project 1 - Start Eeschema, setup Sheet 2 - Add symbols 3 - Arrange, annotate, associate 4 - Wiring 5 - Nets 6 - The Electrical Rules Check 7 - Comments with text and graphics Part 4: Project- A hands-on tour of KiCad - Layout 1. Introduction to layout design and objective of this section 1 - Start Pcbnew, import footprints 2 - Outline and constraints (edge cut) 3 - Move footprints in place 4 - Route (add tracks) 5 - Reﬁne the outline 6 - Silkscreen (text and graphics) 15 29 30 36 41 43 47 56 57 58 64 72 76 78 82 87 89 90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 93 94 ?? ?? ?? ?",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 34
  },
  {
    "text": "15 29 30 36 41 43 47 56 57 58 64 72 76 78 82 87 89 90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 93 94 ?? ?? ?? ?? ?? ?? 7 - Design rules check 8 - Export Gerbers and order The manufactured PCB Part 5: Design principles and PCB terms Introduction Schematic symbols PCB key terms FR4 Traces Pads and holes Via Annular ring Soldermask Silkscreen Drill bit and drill hit Surface mounted devices Gold Fingers Keep-out areas Panel Solder paste and paste stencil Pick-and-place Part 6: PCB design workﬂows The KiCad Schematic Design Workﬂow Schematic Design Step 1: Setup Schematic Design Step 2: Symbols Schematic Design Step 3: AAA (Arrange, Annotate, Associate) Schematic Design Step 4: Wire Schematic Design Step 5: Nets Schematic Design Step 6: Electrical Rules Check Schematic Design Step 7: Comments and Graphics",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 35
  },
  {
    "text": " Nets Schematic Design Step 6: Electrical Rules Check Schematic Design Step 7: Comments and Graphics The KiCad Layout Design Workﬂow Layout Design Step 1: Setup Layout Design Step 2: Outline and constraints Layout Design Step 3: Place footprints Layout Design Step 4a: Route Layout Design Step 4b: Copper ﬁlls Layout Design Step 5: Silkscreen Layout Design Step 6: Design rules check 16 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? Layout Design Step 7: Export & Manufacture Part 7: Fundamental Kicad how-to: Symbols and Eeschema Introduction Left menu bar overview Top menu bar overview Right menu bar overview Schematic editor preferences How to ﬁnd a symbol with the Chooser How to ﬁnd schematic symbols on the Internet How to i",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 36
  },
  {
    "text": "eferences How to ﬁnd a symbol with the Chooser How to ﬁnd schematic symbols on the Internet How to install symbol libraries in bulk How to create a custom symbol How to associate a symbol with a footprint Net labels Net classes Hierarchical sheets Global labels Hierarchical labels and import sheet pin Electrical rules and customization Bulk editing of schematic elements Part 8: Fundamental Kicad how-to: Footprints and Pcbnew Introduction Left toolbar Top toolbar Top toolbar Row 1 Top toolbar Row 2 Right toolbar Right toolbar main buttons Right toolbar - Appearance Layout editor preferences Board Setup Board Setup - Board Stackup Board Setup - Text & Graphics Board Setup - Design Rules and net classes Board Setup - Design Rules - Custom Rules and violation severity How to ﬁnd and use a foot",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 37
  },
  {
    "text": "t classes Board Setup - Design Rules - Custom Rules and violation severity How to ﬁnd and use a footprint Footprint sources on the Internet How to install footprint libraries Filled zones 17 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? Keep-out zones Interactive router Length measuring tools Bulk editing Create a custom footprint, introduction Create a new library and footprint Create a footprint, 1, Fabrication layer Create a footprint, 2, Pads Create a footprint, 3, Courtyard layer Create a footprint, 4, Silkscreen layer Use the new footprint Finding and using a 3D shape for a footprint How to export and test Gerber ﬁles Part 9: Project - Design a simple breadboard power supply PCB 1. Introduction Schematic design editi",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 38
  },
  {
    "text": "Part 9: Project - Design a simple breadboard power supply PCB 1. Introduction Schematic design editing 1 - Setup 2 - Symbols 2 - Edit Component values 3 - Arrange, Annotate 3 - Associate 4 - Wiring 5 & 6 - Nets and Electrical Rules Check 7 - Comments Layout design editing 1 - Setup 2 - Outline and constraints 3 - Place footprints 2 - Reﬁne the outline 4 - Route 5 - Copper ﬁlls 6 - Silkscreen 7 - Design Rules Check 8 - Export and Manufacture Part 10: Project - A 4 x 8 x 8 LED matrix array 1. Introduction Schematic design 1 - Setup 18 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 96 97 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 102 103 ?? Schematic design Schema 1 - Setup Schema 2 - Symbols Schema 3 - Arrange, Annotate Schema 3 - Associate Schema 4 - Wiring Schema 5 - Nets Schema 6 - ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 39
  },
  {
    "text": "bols Schema 3 - Arrange, Annotate Schema 3 - Associate Schema 4 - Wiring Schema 5 - Nets Schema 6 - Electrical Rules Check Schema 7 - Comments Schema - Last-minute edits Layout design Layout 1 - Setup Layout 2 - Outline and constraints Layout 3 - Place components Layout 2 supplemental - Reﬁne outline Layout 3 supplemental - Move footprints to back layer Layout 4 - Route Layout 4 - Copper ﬁlls Layout 5 - Silkscreen Layout 6 - Design Rules Check Layout 7 - Manufacture Bonus - 3D shapes Bonus - Found a bug in the schematic! (and ﬁx) The assembled and working PCB 2 - Symbols 3 - Arrange, Annotate 3 - Associate 4 - Wiring 5 - Nets 6 - Electrical Rules Check 7 - Comments Last-minute edits Layout design editing 1 - Setup 2 - Outline and constraints 3 - Place components 2 - Reﬁne outline 3 - Move ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 40
  },
  {
    "text": "esign editing 1 - Setup 2 - Outline and constraints 3 - Place components 2 - Reﬁne outline 3 - Move footprints 19 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 4 - Route 4 - Copper ﬁlls 5 - Silkscreen 6 - Design Rules Check 7 - Manufacture Bonus - 3D shapes Bonus - Found a bug in the schematic! (and ﬁx) Bonus - 3D shapes Bonus - Found a bug in the schematic! (and ﬁx) The assembled and working PCBThe assembled and working PCB Bonus - Found a bug in the schematic! (and ﬁx) The assembled and working PCBSchematic design Schema 1 - Setup Schema 2 - Symbols Schema 3 - Arrange, Annotate Schema 3 - Associate Schema 4 - Wiring Schema 5 - Nets Schema 6 - Electrical Rules Check Schema 7 - Comments Schema - Last-minute edits Layout design Layout 1 - Setup Layout 2 - Outline and constraints Layout 3 - P",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 41
  },
  {
    "text": "a - Last-minute edits Layout design Layout 1 - Setup Layout 2 - Outline and constraints Layout 3 - Place components Layout 2 supplemental - Reﬁne outline Layout 3 supplemental - Move footprints to back layer Layout 4 - Route Layout 4 - Copper ﬁlls Layout 5 - Silkscreen Layout 6 - Design Rules Check Layout 7 - Manufacture Bonus - 3D shapes Bonus - Found a bug in the schematic! (and ﬁx) The assembled and working PCB Part 11 : Project - MCU datalogger 1. Project - Introduction Create the new project and Git repository 20 ?? ?? ?? ?? ?? ?? ?? ?? 108 109 ?? Schematic design Schema 1 - Setup Schema 2 - Symbols Schema 2 - Sheet two Schema 3 - Arrange, Annotate Edit component values Schema 3 - Associate Schema 4 - Wiring of sheet 1 Schema 4 - Wiring of sheet 2 Schema 5 - Nets Schema 6 - Electrical",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 42
  },
  {
    "text": "iate Schema 4 - Wiring of sheet 1 Schema 4 - Wiring of sheet 2 Schema 5 - Nets Schema 6 - Electrical Rules Check Schema 7 - Comments Create the 2-layer branch in Git Layout design Layout 1 - Setup Layout 2 - Outline and constraints Layout 3 - Place components Layout 2 - Outline reﬁnement Layout 4 - Route Layout 4 - Copper ﬁlls Layout 4 - Routing improvements Layout 5 - Silkscreen Layout 4 - Routing violations and complete silkscreen Layout 6 - Design Rules Check Layout 7 - Manufacture 3D shapes Merge 2-layer branch to main Design 4 Layer PCB in new Git branch Four-layer PCB routing Four-layer PCB manufacturing Updating layout from changes to the schematic with Git Part 12 : Project - An ESP32 clone 1. Project - Introduction Schematic design Schema 1 - New KiCad project and Schematic Setup ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 43
  },
  {
    "text": "2 clone 1. Project - Introduction Schematic design Schema 1 - New KiCad project and Schematic Setup Schema 2 - Symbols Schema 3 - Annotate and set component values Schema 3 - Arrange 21 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 113 ?? ?? ?? ?? ?? Schema 3 - Associate Schema 4 - Wiring Schema 5 - Nets and Net Classes Schema 6 - Electrical Rules Check Schema 7 - Comments Layout design Layout 1 - Setup Layout 2 - Outline and constraints Layout 3 - Place components Layout 2 supplemental - reﬁne outline Layout 4 - Route Layout 4 - Copper ﬁlls and keep out areas Layout 5 - Silkscreen Layout 4 - Routing improvements Layout 6 - Design Rules Check Layout 7 - Manufacture 3D shapes Part 13: Recipies Create a custom silkscreen or copper graphic Cha",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 44
  },
  {
    "text": " Layout 7 - Manufacture 3D shapes Part 13: Recipies Create a custom silkscreen or copper graphic Change a symbols and footprints in bulk Change a symbol in bulk Change a footprint in bulk Interactive delete Find and Replace (Eeschema) Edit Text & Graphics Properties Edit Track & Via Properties (Pcbnew) Text variables Board Setup - pre-deﬁned sizes for tracks and vias Board Setup - Design rules violation severity Board Setup - Custom design rules Schematic Setup - Electrical Rules and violation severity Schematic Setup - Electrical Rules and Pin conﬂicts map Field name templates Bill of Materials Build-in BOM in Pcbnew Build-in BOM in Eeschema A plug-in for BOM Import components from Snapeda 22 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 45
  },
  {
    "text": "22 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? The Freerouting autorouter Install and start FreeRouting on MacOS Install and start FreeRouting on Linux Kubuntu Install and start FreeRouting on Windows How to use the Freerouting autorouter 2-layer example How to use the Freerouting autorouter 4-layer example Pcbnew Inspection menu Single track and differential pair routing Track length tuning Differential pair skew tuning Interactive router modes The footprint wizard Pin and wire highlighter tool Pcbnew Origins KiCad project management with Git Install Git Git conﬁguration Create a new KiCad project Git repository How to ignore ﬁles Basic Git commands: add, commit Basic Git commands: branch Basic Git commands: merge Shari",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 46
  },
  {
    "text": "nore ﬁles Basic Git commands: add, commit Basic Git commands: branch Basic Git commands: merge Sharing your KiCad project on GitHub Customize the editor color scheme Import an EAGLE, Altium, or Cadstar project The circuit simulator Prepare the circuit for simulation Conﬁgure the simulator Simulate Import a KiCad 5 project KiCad project templates Using a system project template Create a user project template Archive/unarchive and share a project Buses Calculate the width of a trace Design a custom schematic sheet 23 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? An introduction: Why KiCad? Since KiCad ﬁrst appeared in the PCB CAD world in 1992, it has gone through 6 major versions and evolved into a serious alternative to comme",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 47
  },
  {
    "text": " world in 1992, it has gone through 6 major versions and evolved into a serious alternative to commercial products. I have been using KiCad almost daily since version 4 when I published the ﬁrst edition of KiCad Like a Pro. Once thought clunky and barely usable, it is now a solid, reliable CAD application. KiCad has been consistently closing the feature and performance gap against its commercial competitors. It has made leaps in adding powerful features and has signiﬁcantly improved its stability. Combined with the beneﬁts of free and open-source software, I believe that KiCad is simply the best PCB CAD software for most use cases. One of those beneﬁts is KiCad's very active and growing community of users and contributors. KiCad has a dedicated developer team, supported by contributing org",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 48
  },
  {
    "text": "unity of users and contributors. KiCad has a dedicated developer team, supported by contributing organizations like CERN, the Raspberry Pi Foundation, Arduino LLC, and Digi-Key Electronics. The community is also active in contributing funds to cover development costs. Since joining the Linux Foundation, the KiCad project has received around $90,000 in donations. The project used this money to buy development time and funding developer conference travel and meetups. To a large extent, this alone guarantees that KiCad's development will accelerate and continue to in the future. Supporting the KiCad core team is the KiCad community. The community consists of over 250 thousand people worldwide that have downloaded a copy. These people support the KiCad project in various ways: they write code,",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 49
  },
  {
    "text": "hat have downloaded a copy. These people support the KiCad project in various ways: they write code, create and share libraries, and help others learn. They write documentation, record videos, report bugs, and share hacks. During the KiCad 6 development cycle, the KiCad repository had around 14600 commits from the community. Based on this number, KiCad 6 is the most signiﬁcant KiCad version ever in terms of changes. Another signal of the strength of the KiCad community is that KiCad 6 includes completed or nearly completed translations to nearly 20 languages. No other CAD software that I am aware of can boast this. PCB manufacturers have also taken notice. Many of them now publish Kicad-speciﬁc tutorials, explaining how to order your boards. Some have made it possible to upload the KiCad n",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 50
  },
  {
    "text": "iﬁc tutorials, explaining how to order your boards. Some have made it possible to upload the KiCad native layout ﬁle from your project instead of generating multiple Gerber ﬁles. And ﬁnally, KiCad is part of an expanding CAD ecosystem. You will ﬁnd KiCad-compatible component libraries on the Internet's major 24 repositories, such as Snapeda and Octopart, as well as native support in PCB project version control software for teams, such as CADLAB.io. KiCad's development and prospects have never been brighter than now. KiCad's roadmap has exciting new features and capabilities such as grouping board objects into reusable snippets and a stable Python API. Why do I use KiCad? Because it is the perfect PCB software for my use case. I am an electrical engineer with a background in electronics and",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 51
  },
  {
    "text": "rfect PCB software for my use case. I am an electrical engineer with a background in electronics and computer engineering. But, above all, I am a technology educator and electronics hobbyist. The majority of my PCB projects eventually ﬁnd themselves in my books and courses. My projects are very similar to those of other hobbyists in terms of complexity and size. I make things for my Arduino and Raspberry Pi courses. As a hobbyist, KiCad proved to be the perfect tool for me. Your use case may be different. You may be a university student completing an engineering degree. You may be a hobbyist or solo developer working in a startup company. You may be part of a team working on commercial projects that involve highly integrated multi-layer PCBs. To help you decide whether KiCad is right for y",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 52
  },
  {
    "text": "cts that involve highly integrated multi-layer PCBs. To help you decide whether KiCad is right for you, I have compiled a list of 12 KiCad Beneﬁts. This list contained ten items in the second edition of the book. I added the last two items to highlight additional beneﬁts brought about with KiCad 6. Here they are: Beneﬁt 1: KiCad is open source. This is very important, especially as I spend more time creating new and more complicated boards. Open source, by deﬁnition, means that the code base of the application is available for anyone to download and compile on their computer. It is why Linux, Apache, and WordPress essentially run the Internet (all of them open-source). While I am not extreme in my choices between open source and closed source software, whenever a no-brainer open-source opt",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 53
  },
  {
    "text": " in my choices between open source and closed source software, whenever a no-brainer open-source option does appear, like KiCad, I take it. Beneﬁt 2: It is free! This is particularly important for hobbyists. CAD tools can be expensive. This is worsening with most CAD software companies switching to a subscription-based revenue model. When you are a hobbyist or student or bootstrapping for a startup, regular fees do add up. Not to mention that most of us would not be using even half of the features of commercial CAD software. It is hard to justify spending hundreds of dollars on PCB software when there is KiCad. This brings me to Beneﬁt 3 25 Beneﬁt 3: KiCad is unlimited. There are no ''standard'', ''premium'' and ''platinum'' versions to choose from. It's a single download, and you get ever",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 54
  },
  {
    "text": "rd'', ''premium'' and ''platinum'' versions to choose from. It's a single download, and you get everything. While there are commercial PCB tools with free licensing for students or hobbyists, there are always restrictions on things like how many layers and how big your board can be, what you can do with your board once you have it, who can manufacture your board, and much more. And there is always the risk that the vendor may change the deal in the future where you may have to pay a fee to access your projects. I'll say again: KiCad is unlimited and forever! This is so important that I choose to pay a yearly donation to CERN that is higher than the cost of an Autodesk Eagle license to do my part in helping to maintain this. Beneﬁt 4: KiCad has awesome features. Features such as interactive",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 55
  },
  {
    "text": "part in helping to maintain this. Beneﬁt 4: KiCad has awesome features. Features such as interactive routing, length matching, multi-sheet schematics, conﬁgurable rules checker, and differential routing are professional-grade. While you may not need to use some of them right away, you will use them eventually. You can add new features through third-party add-ons. The external autorouter is one example. The ability to automate workﬂows and extend capabilities through Python scripts is another. Beneﬁt 5: KiCad is continually improved. Especially since CERN & Society Foundation became involved in their current capacity, I have seen a very aggressive and successfully implemented roadmap. When I wrote the ﬁrst version of this list (August 2018), KiCad 5 was about one month old. The funding for ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 56
  },
  {
    "text": "wrote the ﬁrst version of this list (August 2018), KiCad 5 was about one month old. The funding for KiCad 6 was already complete, and the road map living document was published. Three years later, KiCad 6 was delivered with promises fulﬁlled. Now, with KiCad 6 published, the road map for the future looks just as exciting. Beneﬁt 6: KiCad's clear separation of schematics and layout is a bonus to learning and using it. Users of other PCB applications often ﬁnd this confusing, but I believe that it is an advantage. Schematic design and layout design are indeed two different things. Schematic symbols can be associated with different footprints that depend on the project requirements. You can use the schematic editor independently of the layout editor or in sync. I often create schematic diagra",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 57
  },
  {
    "text": " the schematic editor independently of the layout editor or in sync. I often create schematic diagrams for my courses that I have no intention of converting into PCBs. I also often create multiple versions of a board using the same schematic. This separation of roles makes both scenarios easy. Beneﬁt 7: I can make my boards anywhere: I can upload my project to any online fabricator that accepts the industry-standard Gerber ﬁles; I can 26 upload it to an increasing number of fabricators that accept the native KiCad layout ﬁle; and, of course, I can make them at home using an etching kit. Beneﬁt 8: KiCad works anywhere. Whether you are a Mac, Windows, or Linux person, you can use KiCad. I use it on all three platforms. I can take my KiCad 6 project from the Mac and continue working on Window",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 58
  },
  {
    "text": "it on all three platforms. I can take my KiCad 6 project from the Mac and continue working on Windows 10 without worrying about any software or project ﬁles glitches. Beneﬁt 9: KiCad is very conﬁgurable. You can assign your favorite keyboard hotkeys and mapping, and together with the mouse customizations, you can fully adapt it to your preferences. With the additions of the plugin system and the Python API, , it will be possible to extend your instance of KiCad with the exact features you need (or write them). Beneﬁt 10: If you are interested in creating analog circuits, you will be happy to know that KiCad ships with SPICE. You can draw the schematic in Eeschema and then simulate it in SPICE without leaving KiCad. This integration ﬁrst appeared in KiCad 5, and it is now a stable feature. ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 59
  },
  {
    "text": "E without leaving KiCad. This integration ﬁrst appeared in KiCad 5, and it is now a stable feature. Beneﬁt 11: In the past, KiCad's release cycle was somewhat chaotic. New major versions would come out every two or three years, but no one knew ahead of time. In the future, KiCad will operate in a yearly release cycle. This is good for two reasons: One, commercial users who can now better predict how the software they depend on will change and when. Two, as KiCad users, all of us will be able to expect a reliable development schedule that prioritizes reliability. KiCad is now mature enough to be able to evolve predictably. Beneﬁt 12: KiCad is now a serious productivity tool for businesses. If you are an electronics engineer, you can proudly list it in your resume. If you are using it in you",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 60
  },
  {
    "text": " you are an electronics engineer, you can proudly list it in your resume. If you are using it in your business, you can contract the KiCad Services Corporation, to customize the software to your exact requirements. I am talking about deep customization, not just changing the theme and the menu bars. This means that KiCad can ﬁt precisely with your business. As far as I know, no commercial CAD application can do that. For the non-business users among us, we can expect many of these business-led improvements to ﬂow into future software versions in the tradition of open-source software. These are the twelve most important reasons I have chosen KiCad as my tool of choice for designing PCBs. These reasons might not be suitable for you, but I hope you will consider reading this book ﬁrst before ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 61
  },
  {
    "text": "e reasons might not be suitable for you, but I hope you will consider reading this book ﬁrst before making your own decision. Over the last seven years, I have packed almost everything I have learned as a KiCad user in this book. I have organized it in a way that will 27 make learning KiCad quick. The objective of this book is to make you productive by the time you complete the ﬁrst project, in part four. If you come from another PCB CAD tool and have experience designing PCBs, I only ask that you have an open mind. KiCad is most certainly very different from your current PCB tool. It looks different, and it behaves differently. It will be easier to learn it if you consciously put aside your expectations and look at KiCad like a beginner would. As per the Borg in Star Trek, ''resistance is",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 62
  },
  {
    "text": " expectations and look at KiCad like a beginner would. As per the Borg in Star Trek, ''resistance is futile”, and in learning, like in so many other aspects of life, you are better off if you go with the ﬂow. Let's begin! 28 Introduction 29 1. What is a PCB? As a child, I remember that my interest in electronics grew from admiration of what these smart engineers had come up with to curiosity about how these things worked. This curiosity led me to use an old screwdriver that my dad had left in a drawer (probably after ﬁxing the hinges on a door) to open anything electronic with a screw large enough for the screwdriver to ﬁt in. A record player, a VCR, a radio; all became my \"victims.\" I am still amazed that a charged capacitor didn't electrocute me. At least, I had the good sense to unplug ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 63
  },
  {
    "text": "ill amazed that a charged capacitor didn't electrocute me. At least, I had the good sense to unplug the appliances from the mains. Inside those devices, I found all sorts of wondrous things: resistors, transformers, integrated circuits, coils, and power supplies. Engineers had attached those things on small green boards, like the one in Figure 1.1.1. This is an example of a printed circuit board, or PCB, for short. Figure 1.1.1: The top side of a printed circuit board. Let's look at the components of a PCB, what a PCB looks like, and the terminology that we use. The example PCB is one I made for one of my courses (Figure 1.1.1). The top side of the PCB is the side where we place the components. We can place components on the bottom side, too. In general, there are two kinds of components: ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 64
  },
  {
    "text": "ts. We can place components on the bottom side, too. In general, there are two kinds of components: through-hole or surface- mounted components. We can attach through-hole components on the PCB by inserting the leads or the pins through small holes and using hot solder to hold them in place. In the example pictured in Figure 1.1.1, you can see 30 several holes to insert the through-hole component pins. The holes extend from the top side to the bottom side of the PCB and are plated with a conductive material. This material is usually tin, or as in the case of the board in the image, gold. We use solder to attach and secure a component through its lead onto the pad surrounding the hole (Figure 1.1.2). Figure 1.1.2: A through-hole component attached to a PCB. If you wish to attach a surface-m",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 65
  },
  {
    "text": " 1.1.2). Figure 1.1.2: A through-hole component attached to a PCB. If you wish to attach a surface-mounted component, then instead of holes, you attach the component onto the surface of the PCB using tin-plated pads. You will use just enough solder to create a solid connection between the ﬂat connector of the component and the ﬂat pad on the PCB (Figure 1.1.3). Figure 1.1.3: A surface-mounted component attached to a PCB. Next is the silkscreen. We use the silkscreen for adding text and graphics. The text can provide helpful information about the board and its components. The graphics can include logos, other decorations, and useful markings. 31 Figure 1.1.4: The white letters and lines is the silkscreen print on this PCB. In Figure 1.1.4, you can see here that I've used white boxes to indi",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 66
  },
  {
    "text": "e silkscreen print on this PCB. In Figure 1.1.4, you can see here that I've used white boxes to indicate the location of various components. I've used text to indicate the names of the various pins, and I've got version numbers up there. It's a good habit to have a name for the PCB and things of that sort. Silkscreen goes on the top or the bottom of the PCB. Sometimes, you may want to secure your PCB onto a surface. To do that, you can add a mounting hole. Mounting holes are similar to the other holes in this board, except they don't need to be tinned. You can use a screw with a nut and bolt on the other side to secure the PCB inside a box. Next are the tracks. In this example (Figure 1.1.5), they look red because of the color of the masking chemical used by the manufacturer. Figure 1.1.5:",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 67
  },
  {
    "text": ", they look red because of the color of the masking chemical used by the manufacturer. Figure 1.1.5: The bright red lines connecting the holes are tracks. Tracks are made of copper, and they electrically connect pins or different parts of the board. You can control the thickness of a track in your design. You can also refer to a \"track\" as a \"trace.\" Notice the small holes that have no pad around them? These are called 'vias.' A via looks like a hole but is not used to mount a component. A via is used to allow a track to continue its route in a different layer. If you're using PCBs with two or more layers, you can use vias to connect a track from any one of the layers to any of the other layers. Vias are handy for routing your tracks around the PCB. 32 The red substance that you see on the",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 68
  },
  {
    "text": "ers. Vias are handy for routing your tracks around the PCB. 32 The red substance that you see on the PCB is the solder mask. It does a couple of things. It prevents the copper on the PCB from being oxidized over time. The oxidization of the copper tracks negatively affects their conductivity. The solder mask prevents oxidization. Another thing that the solder mask does is to make it easier to solder by hand. Because pads can be very close to each other, soldering would be complicated without the solder mask. The solder mask prevents hot solder from creating bridges between pads because it prevents it from sticking on the board (Figure 1.1.6). The solder mask prevents bridges because the solder cannot bond with it. Figure 1.1.6: A solder bridge like this one is a defect that a solder mask c",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 69
  },
  {
    "text": "er cannot bond with it. Figure 1.1.6: A solder bridge like this one is a defect that a solder mask can prevent. Often, the tip of the solder, the soldering iron, is almost as big or sometimes as bigger than the width of the pads, so creating bridges in those circumstances is very easy, and a solder mask helps in preventing that from happening. In Figure 1.1.7 you can see an example of the standard 1.6mm thick PCB. Figure 1.1.7: This PCB has a thickness of 1.6mm, and is made of ﬁberglass. Typically, PCBs are made of ﬁberglass. The typical thickness of the PCB is 1.6 millimeters. In this closeup view of a PCB picture (Figure 1.1.8), you can see the holes for the through-hole components. The holes for the through-hole components are the larger ones along the edge of the PCB. Notice that they ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 70
  },
  {
    "text": "les for the through-hole components are the larger ones along the edge of the PCB. Notice that they are tined on the inside, electrically connecting the front and back. 33 Figure 1.1.8: A closeup view of the top layer. In Figure 1.1.8, you can see several vias (the small holes) and tracks, the red solder mask, and the solder mask between the pads. In this closeup, you can also see the detail of the silkscreens. The white ink is what you use in the silkscreen to create the text and graphics. Figure 1.1.9 is interesting because it shows you a way to connect grounds and VCC pads to large areas of copper, which is called the copper ﬁll. Figure 1.1.9: Thermal relief connects a pad to a copper region. In Figure 1.1.9, the arrow points to a short segment of copper that connects the pad to a large",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 71
  },
  {
    "text": "ion. In Figure 1.1.9, the arrow points to a short segment of copper that connects the pad to a large area of copper around it. We refer to this short segment of copper as a 'thermal relief.' Thermal reliefs make it easier to solder because the soldering heat won't dissipate into the large copper area. Figure 1.1.10 gives a different perspective that allows us to appreciate the thickness of the tracks. Figure 1.1.10: The plating of the holes covers the inside of the hole and connects that front end with the back end. 34 Notice the short track that connects the two reset holes (RST)? The light that reﬂects off the side of the track gives you an idea of the thickness of that copper, which is covered by the purple solder mask. In this picture, you can also see a very thin layer of gold that co",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 72
  },
  {
    "text": "vered by the purple solder mask. In this picture, you can also see a very thin layer of gold that covers the hole and the pad and ﬁlls the inside of the hole. This is how you electrically have both sides of the hole connected. Instead of gold plating, you can also use tin plating to reduce manufacturing costs. Figure 1.1.11: A detail of this example board at 200 times magniﬁcation. The image in Figure 1.1.11 was taken at 200 times magniﬁcation. You can see a track that connects two pads and the light that reﬂects off one side of the track. 35 2. The PCB design process To design a printed circuit board, you have to complete several steps, make decisions, and iterate until you are satisﬁed with the result. A printed circuit board is a physical device that takes time and money to manufacture.",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 73
  },
  {
    "text": "h the result. A printed circuit board is a physical device that takes time and money to manufacture. It must be ﬁt to perform its intended purpose, and must be manufacturable. Therefore, your design must be of high quality, safe, and possible to manufacture by your chosen manufacturer. Apart from the practical considerations of designing a PCB, there are also the aesthetic ones. You want your work to look good, not just to function well. Designing a PCB, apart from being an engineering discipline, is also a form of art. Figure 1.2.1: Some considerations of the PCB design process. In this book, you will learn about the technical elements of designing a PCB in KiCad, but I am sure that as you start creating your PCBs, your artistic side will emerge. Over time, your PCB will start to look uni",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 74
  },
  {
    "text": "start creating your PCBs, your artistic side will emerge. Over time, your PCB will start to look uniquely yours. PCB design is concerned with the process of creating the plans for a printed circuit board. It is different from PCB manufacturing. In PCB design, you learn about the tools, process, and guidelines useful for creating such plans. In PCB manufacturing, on the other hand, you are concerned about the process of converting the plans of a PCB into the actual PCB. 36 As a designer of printed circuit boards, it is useful to know a few things about PCB manufacturing, though you surely do not need to be an expert. You need to know about the capabilities of a PCB manufacturing facility so that you can ensure that your design does not exceed those capabilities and that your PCBs are manufa",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 75
  },
  {
    "text": "hat you can ensure that your design does not exceed those capabilities and that your PCBs are manufacturable. As a designer, you need to have an understanding of the design process, and the design tools. To want to design PCB, I assume that you already have a working knowledge of electronics. Designing a PCB, like much else in engineering, is a procedural and iterative process that contains a signiﬁcant element of personal choice. As you build up your experience and skills, you will develop your unique designing style and process. Figure 1.2.2: KiCad is a suite of applications. KiCad is not a single application. It is a suite of apps that work together to help you create printed circuit boards. As a result, it is possible to customise the PCB design process to suit your particular style an",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 76
  },
  {
    "text": "ds. As a result, it is possible to customise the PCB design process to suit your particular style and habits.But when you are just starting up, I think it is helpful to provide a workﬂow that you can use as a model. In Figure 1.2.2 you can see my KiCad PCB design workﬂow model. You can use it as it is, or you can modify as you see ﬁt. I distilled this workﬂow by drawing from my own experience and learning from other people’s best practices. I also tried to simplify this process and make it suitable for people new to PCB design. In this book, I will be following this PCB design workﬂow in all of the projects. From a very high-level perspective, the PCB design workﬂow only has two major steps: 37 1. Step 1 is the schematic design using the schematic design editor (Eeschema); 2. Step 2 is the",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 77
  },
  {
    "text": " 37 1. Step 1 is the schematic design using the schematic design editor (Eeschema); 2. Step 2 is the layout design using the layout editor (Pcbnew). Once you have the layout design, you can export it and the manufacture it. The goal of the schematic design step is to capture information about the circuit that will be implemented in the ﬁnal PCB. Once you have a schematic design, you can use the layout editor to create a version of the PCB. Remember, a schematic design can have many different layouts. Figure 1.2.3: The KiCad layout ﬁle contains information about the physical PCB. The KiCad layout ﬁle contains information about your board, which the manufacturer can use to create the board. The layout must contain information about the size and shape of the board; its construction (such as h",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 78
  },
  {
    "text": "e layout must contain information about the size and shape of the board; its construction (such as how many layers it must have); the location of the components on the board, the location of various board elements, like pads, holes, traces and cutouts; the features of these elements (such as the sizes of holes and traces); and much more (which you will learn in detail later in this book). Let’s walk through through the workﬂow now using the diagram in Figure 1.2.3 as an aid. For the discussion that follows, keep in mind these deﬁnitions: • A symbol is a symbolic representation of a real component in the schematic; a symbol represents a component's function, not its physical appearance or location in the ﬁnal PCB. 38 • A footprint is a graphical depiction of a real component in the layout. ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 79
  },
  {
    "text": "ation in the ﬁnal PCB. 38 • A footprint is a graphical depiction of a real component in the layout. It relates directly to a real physical counterpart. It contains information about the real component’s location and dimensions. In this book, I will be using the terms “symbols” and footprints according to the deﬁnitions above. In KiCad, the process begins with Eeschema, which is the schematic editor. In Eeschema you create the electrical schematic that describes the circuit that eventually will be manufactured into the PCB. You draw the schematic by selecting symbols from the library and adding them to the schematic sheet. If a component that you need doesn’t exist in the library, you can search for it on the Internet, or create yourself with the help of the schematic library editor. Runnin",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 80
  },
  {
    "text": "rch for it on the Internet, or create yourself with the help of the schematic library editor. Running regular electrical rules checks helps to detect defects early. Eeschema has a built-in checker utility for this purpose. Pcbnew (KiCad's layout editor) has its own validator, the Design Rules Checker. These two utilities help to produce PCBs that have a low risk to contain design or electrical defects. Before you ﬁnish work in Eeschema and continue with the layout, you must ﬁrst associate the schematic symbols with layout footprints. In KiCad 6, many symbols come with preset symbol to footprint associations, but many don't, so you'll have to do this yourself. Also keep in mind that, as I said earlier, KiCad is very ﬂexible. It is possible to assign many different footprints to the same sch",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 81
  },
  {
    "text": "d earlier, KiCad is very ﬂexible. It is possible to assign many different footprints to the same schematic symbol (one at a time, of course). Once you have completed the Electrical Rules Check and symbol to footprint associations, you can continue with layout using the KiCad Layout design editor, or Pcbnew. You use Pcbnew to position the footprints on the sheet and connect the footprint pins using wires. You'll also add an outline that marks the outer limit of the PCB, and other design elements like mounting holes, logos, and instructional text. Once you have your PCB laid out and have its traces completed, you can go ahead and do the design rules check. This check looks for defects in the board, such as a trace that is too close to a pad or two footprints overlapping. Let's look at some o",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 82
  },
  {
    "text": "oard, such as a trace that is too close to a pad or two footprints overlapping. Let's look at some of the PCB terminology before we continue. 39 Figure 1.2.4: Symbols and footprints. As you know, a symbol is a symbolic representation of a real component in the schematic. A footprint is a graphical depiction of a real component in the layout. You, as the designer, must tell KiCad which footprint you want to use in your PCB by associating it to a particular symbol. Take the example of a resistor. A resistor uses a speciﬁc symbol in the schematic, but on the PCB it can be realized as a through-hole or SMD device of varying sizes. When you are ﬁnished working on the layout, you can continue with the last step which involves exporting the layout information in a format that is compatible with y",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 83
  },
  {
    "text": " the last step which involves exporting the layout information in a format that is compatible with your board manufacturer’s requirement. The industry standard for this is a format called ‘Gerber.’ Gerber ﬁles contain several related ﬁles, with one Gerber ﬁle per layer on your PCB, and contain instructions that the fabrication house needs to manufacture your PCB. Let’s move on to the next chapter where we’ll talk about fabrication. 40 3. Fabrication Imagine that you have ﬁnished laying out your board in KiCad, and you’re ready to make it. What are your options? One option is to make your PCBs at home. There’s a guide available on the Fritzing website. The process described in the Fritzing guide is called etching. It involves the use of various chemicals in chemical baths. Some of these che",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 84
  },
  {
    "text": "ide is called etching. It involves the use of various chemicals in chemical baths. Some of these chemicals are toxic. You have to have special safety equipment and keep your children and pets away. The process emits smelly and potentially dangerous fumes. Once you have your board etched, you still need to use a drill to make holes and vias and then ﬁgure out how to connect your top and bottom layers. If this sounds like not your kind of thing (I’m with you!), then you can opt for a professional PCB manufacturer service. PCBWay, NextPCB, and OSH Park are very good at what they offer. You can get a professionally made PCB for around $15 for several copies and without danger to yourself as well. I’ve used OSHPark (great for beginners thanks to its straightforward user interface) and PCBWay (g",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 85
  },
  {
    "text": ". I’ve used OSHPark (great for beginners thanks to its straightforward user interface) and PCBWay (great for more advanced projects that need an extensive array of manufacturing options) extensively. I’m always happy with the result. Using an online manufacturer takes a little bit of planning because once you order your PCBs, it can take up to several weeks to be delivered. If you’re in a hurry, there are options to expedite the process if you are willing to pay a premium. The typical small standard two-layer order costs around $10 for a two square inch board; you get three copies of that. This price works out to around $5 per square inch. The pricing is consistent in the industry, where the main cost factor is the size of the PCB. There is a strong incentive to make your PCBs as small as ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 86
  },
  {
    "text": " main cost factor is the size of the PCB. There is a strong incentive to make your PCBs as small as possible. Be aware of this when you design your layout. 41 Figure 3.3.1: An example of the Gerber ﬁles that the manufacturer will need in order to make your PCB. Now, let’s turn our attention to the ﬁles you need to upload for these services — and the ﬁles are Gerber ﬁles. Each layer on your PCB has its own Gerber ﬁle, which is simply a text ﬁle. Figure 3.3.2 shows the contents of an example Gerber ﬁle. Figure 3.3.3: Gerber ﬁles contain text You can see that this is just a text-based ﬁle that contains instructions. An advantage of this text format is that you can use a version control system like Git to maintain your project history and store and share via online repositories like Github. Uc",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 87
  },
  {
    "text": "ike Git to maintain your project history and store and share via online repositories like Github. Ucamco has designed the Gerber ﬁles system and standard. They make equipment and write software for PCB manufacturers — things like PreCAM software, PCB CAM, laser photoplotters, and direct imaging systems. If you’re curious about how to read these Gerber ﬁles, you can look up the Gerber format speciﬁcation on Ucamco’s website. 42 4. Get KiCad for your operating system It is now time to download your copy of KiCad and install it on your computer. Kicad has support for a variety of operating systems. The major operating systems, Mac OS and Windows, are supported. Of course, there is support for Ubuntu and a lot of different ﬂavors of Linux. I have tested, and I frequently use KiCad on Mac OS. M",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 88
  },
  {
    "text": "buntu and a lot of different ﬂavors of Linux. I have tested, and I frequently use KiCad on Mac OS. Mac OS is my primary operating system, but I'm also working on Windows and Kubuntu instead of Ubuntu. Kubuntu is based on Ubuntu in its core but uses the KDE Desktop and related software. I ﬁnd Kubuntu to offer a much better experience compared to Ubuntu. Of course, this is my personal preference, and opinions vary greatly. I'm not going to show you how to install KiCad on each one of those operating systems. The KiCad developer team has reﬁned the installer over the years. The KiCad installation process on the supported operating systems is just like that of any other reﬁned application. Figure 1.4.1: Windows stable release download page. For example, to get the KiCad installer for Windows, ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 89
  },
  {
    "text": "e 1.4.1: Windows stable release download page. For example, to get the KiCad installer for Windows, go to the KiCad Windows page and download the stable version of KiCad from your preferred source. Double-click on the installer icon and follow the installation wizard instructions to complete the installation on your computer. 43 Figure 1.4.2: Nightly build download You can download and install the latest available version of KiCad that is available as a nightly build. Nightly builds are work-in-progress. They contain the latest code committed by the KiCad developers but are considered \"unstable.\" Therefore, you should not use it for work that you do not want to lose. The major operating systems have a nightly build generated (almost) every night. If you want to look at the cutting-edge ver",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 90
  },
  {
    "text": "ems have a nightly build generated (almost) every night. If you want to look at the cutting-edge version of KiCad and you are not afraid of weird behaviors and strange crashes, then go to the nightly releases page for your preferred operating system and download the installer. Example: Windows. 44 Figure 1.4.3: Nightly build download If you're working on Mac OS, go to the Mac OS downloads page and download the latest available stable release. You can also download a nightly build if you are comfortable with the inherent risk. Both stable and nightly builds come as a regular DMG ﬁle. The download ﬁle contains the entire KiCad suite with all its applications, the documentation, and the libraries for the schematic symbols, footprints, and templates. It also includes several demos projects. Th",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 91
  },
  {
    "text": "es for the schematic symbols, footprints, and templates. It also includes several demos projects. The installation process makes use of Ubuntu's apt-get system. For Ubuntu, you can ﬁnd installations instructions on the Ubuntu page. For using nightly development builds in Ubuntu, you will ﬁnd instructions on the same page. There is there are similar instructions for the various other operating systems like Suse and Fedora. You also have the option to download the source code and build from the source on your operating system. This is not something that I usually do unless I want to play around with it and experiment. Luckily, the operating systems I use or have excellent binary builds, so I never needed to build my KiCad instance from the source. But if you are someone who enjoys doing that",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 92
  },
  {
    "text": "ever needed to build my KiCad instance from the source. But if you are someone who enjoys doing that, then go to the source code page and follow the detailed instructions. At this point, I invite you to download the version of KiCad that is suitable for your operating system and install KiCad on your computer. Once you ﬁnish installing KiCad, verify that it's up and running by starting KiCad. 45 In the next chapter, you will use your brand new instance of KiCad to look at some of the demo projects that ship with KiCad. 46 5. Example KiCad projects Now that you have installed your instance of KiCad let's start your familiarisation with it by looking at one of the examples that come with it. Browse to the KiCad demos folder, and download the one titled 'pic programmer' (Figure 1.5.1). You ca",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 93
  },
  {
    "text": "rowse to the KiCad demos folder, and download the one titled 'pic programmer' (Figure 1.5.1). You can also download the entire “demos” folder if you wish. Figure 1.5.1: The contents of the 'pic programmer' demo project folder. The demo project folder contains several ﬁles that make up the project. For now, the ones to focus on have the extensions' kicad pro,' 'kicad pcb' and 'kicad sch.' The ﬁle with the 'kicad pro' extension contains project information. The 'kicad pcb' ﬁle contains layout information. The ﬁles with the 'kicad sch' extension contain schematic information. There are two 'kicad sch' ﬁles because this project includes two schematics. Double-click on the 'kicad pro' (project) ﬁle. The main KiCad window will appear. This window is the launchpad for the other KiCad apps, like E",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 94
  },
  {
    "text": "le. The main KiCad window will appear. This window is the launchpad for the other KiCad apps, like Eeschema (the schematic editor) and Pcbnew (the layout editor). You can see the main KiCad window in Figure 1.5.2. 47 Figure 1.5.2: The main KiCad window. Let's explore the schematic of this demo project. The main KiCad window shows the project ﬁles in the left pane, the various app buttons in the top-right pane, and various status messages in the bottom right pane. In the right pane, click on the Schematic Editor button. This button will start the Eeschema application, the schematic layout editor. You should see the editor as in the example in Figure 1.5.3. Figure 1.5.3: The schematic editor. 48 A few things are going on here. At ﬁrst, this window might seem overwhelming. Don't worry about t",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 95
  },
  {
    "text": "48 A few things are going on here. At ﬁrst, this window might seem overwhelming. Don't worry about the various buttons and menus; concentrate on the schematic itself. Look at the various symbols, like those for the diodes, the transistors, and the operational ampliﬁers. There are symbols for resistors, and connectors, with green lines connecting their pins. Notice how text labels give names to the symbols but also the wirings between pins. Notice how even the mounting holes at the bottom right side of the schematic have names. Even though these mounting holes are not electrically active, they are depicted in the schematic. The values of the capacitors and resistors are noted, and any pins that are not connected to other pins are marked with an 'x's. There is a rectangular symbol on the rig",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 96
  },
  {
    "text": "at are not connected to other pins are marked with an 'x's. There is a rectangular symbol on the right side of the schematic with the title 'pic sockets' (Figure 1.5.4). Double click on it. What happened? Figure 1.5.4: A link to another sheet. This symbol links to another sheet, which contains additional symbols that are part of the same schematic. It looks like the example in Figure 1.5.5. 49 Figure 1.5.5: KiCad’s schematics can span over multiple sheets. KiCad's schematics can span over multiple sheets. Add more if your schematic is too large to ﬁt in one sheet comfortably (you will learn how to do this in this book). I encourage you to spend a bit of time studying this schematic. You can learn a lot about drawing good schematic diagrams by studying good schematic diagrams, just like you",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 97
  },
  {
    "text": "learn a lot about drawing good schematic diagrams by studying good schematic diagrams, just like you can learn programming by studying good open-source code. Go back to the main KiCad window. Click on the button labeled \"PCB Editor.\" This will launch Pcbnew, the layout editor. The window that appears will look like the example in Figure 1.5.6. 50 Figure 1.1.5.6: Pcbnew, the layout editor. Again, don't worry about the various buttons and menus; concentrate on the layout inside the sheet. Use your mouse's scroll wheel to zoom in and out and the Alt+right mouse button to pan (you should also be able to pan by holding down the middle mouse button). Zoom in and look at some of the layout details, such as the pads, how they are connected to traces, the names that appear on the pads and traces, a",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 98
  },
  {
    "text": " such as the pads, how they are connected to traces, the names that appear on the pads and traces, and the colors of the front copper and back copper layer traces. Note: in Linux, panning is done with the middle mouse button, and the alt key is not used. Also, compare how a footprint in the layout compares to the symbol in the schematic. You can see a side-by-side comparison in Figure 1.5.7. Figure 1.5.7: A side-by-side comparison of a footprint (left) and its schematic symbol (right). 51 Associated symbols and footprints have the same designator (J1, in this example) and the same number of pins. The layout shows the traces that correspond to the wires in the schematic. Everything you see here is conﬁgurable: the width of the traces, which layer they belong to, the shape, size, and conﬁgur",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 99
  },
  {
    "text": "re is conﬁgurable: the width of the traces, which layer they belong to, the shape, size, and conﬁguration of the pads. You will learn all of this in this book. In the layout, zoom in on the J1 connector to see one of its details: the name of the trace that connects pad 7 of J1 to pad 1 of R5. Traces, like everything else in KiCad, have names. The names of everything that you see in Pcbnew are deﬁned (manually or automatically) in Eeschema. Figure 1.5.8: Traces have names. Try one more thing: In Pcbnew, click on the View menu and choose the 3D Viewer. The 3D Viewer will show you a three-dimensional rendering of the PCB, with remarkable detail. You can zoom in and turn the board around to see it from any angle you want (Figure 1.5.9). Many components are populated, like the LED, resistors, a",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 100
  },
  {
    "text": "it from any angle you want (Figure 1.5.9). Many components are populated, like the LED, resistors, and some of the integrated circuits. For the rest, you can still see their pads and outlines on the board. 52 Figure 1.5.9: The 3D viewer will give you a realistic rendering of your board that you can examine in 3D. As with the schematic editor, I encourage you to spend a bit of time studying the layout of this demo project. Later in this book, you will learn about the most important layout guidelines that will help you design well- functioning and elegant PCBs. Apart from the demo projects that KiCad ships with, you should also look at some of the very impressive showcased projects of boards “made with KiCad”. For example, the CSEduino is a 2-layer PCB that contains an Atmega328P microcontro",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 101
  },
  {
    "text": "made with KiCad”. For example, the CSEduino is a 2-layer PCB that contains an Atmega328P microcontroller and implements a simple Arduino clone. You will be able to easily create a board like this by the time you ﬁnish this book. Go to txplo.re/madewkicad for more examples of projects made with KiCad. 53 Figure 1.5.10: Featured board 'Made with KiCad': CSEduino. Another featured board is Anavi Light, a HAT board for the Raspberry Pi. This is also a 2-layer board that allows you to control a 12V LED strip and get readings from sensors. Figure 1.5.11: Featured board 'Made with KiCad': Anavi Light. Finally, a truly impressive board made with KiCad is Crazyﬂie (Figure 1.5.12). Crazyﬂie is a dense 4-layer PCB with a rather elaborate shape. The board implements the ﬂight controller of a tiny dron",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 102
  },
  {
    "text": " 4-layer PCB with a rather elaborate shape. The board implements the ﬂight controller of a tiny drone. The shape is 54 speciﬁcally designed to implement the drone's body and arms. You will also learn how to create PCBs with complicated shapes in this book. Figure 1.5.12: Featured board 'Made with KiCad': Crazyﬂie. With this chapter complete, you should now understand the kinds of projects that people use KiCad. These are also the kinds of boards that you will design by the time you complete this book. Let's get straight into the ﬁrst project so that you can start discovering this fantastic tool by doing. 55 Part 2: Getting started with KiCad 6 56 1. Introduction Welcome to Part 2 of this book. In the chapters of this Part, I will give you a brief overview of KiCad 6. This overview will hel",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 103
  },
  {
    "text": "k. In the chapters of this Part, I will give you a brief overview of KiCad 6. This overview will help you with the ﬁrst hands-on activity of this course, in which you will create your ﬁrst PCB in the chapters of the following two Parts. Ensure that you have installed KiCad on your computer so that you can follow along. If you haven't done so yet, please go back to chapter \"4. Get KiCad for your operating system,\" where I provide information on installing KiCad on Mac OS, Windows, and Linux. In the following chapters, I will introduce the individual apps that make up the KiCad software suite. I will also explain the roles of paths to the symbol, footprint, 3D model, and template libraries, show you how to create a new project from scratch and a template. I will also compare KiCad 6 as it ru",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 104
  },
  {
    "text": "ow you how to create a new project from scratch and a template. I will also compare KiCad 6 as it runs on the three supported platforms. If you have experience with KiCad 5, read the relevant chapter at the end of this Part. Let's continue with the following chapter, where I'll give you an overview of KiCad's core apps. 57 2. KiCad Project Manager (main window) This chapter will give you an overview of the KiCad project manager, otherwise known as the \"main\" KiCad window. Figure 2.2.1: The KiCad Project Manager window. This is the window that you will see ﬁrst when you start KiCad. The project manager gives you access to the various KiCad applications, like the schematic and symbol editors, and shows you the project ﬁles. The main window contains: A toolbar on the left. The project ﬁles ar",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 105
  },
  {
    "text": "and shows you the project ﬁles. The main window contains: A toolbar on the left. The project ﬁles are in the middle. The application buttons are on the right side. ◦ ◦ ◦ The left toolbar has buttons to create a new project or open an existing project and archive/unarchive. The middle pane shows the project ﬁles and folders. This is essentially a ﬁle browser that gives you access to the individual ﬁles and folders inside the main KiCad project directory. The right pane contains buttons for the individual applications. Say that you want to start the schematic editor. You can do this in three ways: 1. Double-click on the ﬁle with the extension \"kicad sch\" in the middle pane (ﬁle browser). 2. Click on the Schematic Editor button in the right pane. 58 3. Click on \"Schematic Editor\" under Tools ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 106
  },
  {
    "text": "ick on the Schematic Editor button in the right pane. 58 3. Click on \"Schematic Editor\" under Tools in the top menu (see below). Figure 2.2.2: Starting the Schematic editor. If you create a new directory via your operating system's ﬁle manager or create a new ﬁle, the middle pane will display those items. Remember that a KiCad project will contain ﬁles that KiCad creates and ﬁles created by other tools, like the Autorouting autorouter and Git. You will learn about the core ﬁles in KiCad later in this book. You will learn about the buttons in the right pane in the next chapter. First, let's do a tour of the items in the top menu bar. Figure 2.2.3: The top menu bar in KiCad. To get information about your instance of KiCad, click on \"About KiCad\" under the KiCad menu item. You will need to us",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 107
  },
  {
    "text": " about your instance of KiCad, click on \"About KiCad\" under the KiCad menu item. You will need to use the information provided in this window if you have found a bug and wish to report it to the development team. 59 Figure 2.2.4: Report a bug. To report a bug, open the About KiCad window, and click \"Report Bug\" (see \"1\" above). This will use your web browser to open the New Issue page in Gitlab. You will need to include your KiCad instance version information, which you can get from the About KiCad window (\"2\", above). Also, from the KiCad menu item, you can bring up the Preferences window. Figure 2.2.5: The KiCad Preferences window. In the Preferences window contains several tabs with widgets that allow you to customize KiCad. Exactly what you see here depends on which applications are op",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 108
  },
  {
    "text": "ts that allow you to customize KiCad. Exactly what you see here depends on which applications are open. In the example above, only the main KiCad project window is open. The right pane would contain additional items if Eeschema or Pcbnew were also open. You can learn about the details in dedicated chapters later in this book (Eeschema, and Pcbnew). Under the File menu, you see the standard options for ﬁle and project management. You can open/close a project, create a new project, archive/ 60 unarchive a project, and import non-KiCad projects. You will ﬁnd some of those options as buttons in the right toolbar of the main KiCad window. Figure 2.2.6: The KiCad File menu. You will be using those options in the projects through this book. In the Recipes part of this book, you can learn how to i",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 109
  },
  {
    "text": " options in the projects through this book. In the Recipes part of this book, you can learn how to import a non-KiCad project, and how to archive/unarchive. Under View, you can use a text editor to view any of KiCad's project ﬁles. You can deﬁne your preferred text editor in the Preference window in the Common tab. Below you can see an example of a KiCad schematic ﬁle loaded in the Atom text editor. Figure 2.2.7: A schematic design ﬁle in a text editor. All KiCad ﬁles are text ﬁles, and as such, you can open them in a text editor. It is also possible to programmatically edit those ﬁles using automation 61 implemented in a language like Python directly, without needing an API. Beware, though: modifying these ﬁles by hand or programmatically without knowing precisely what you are doing will ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 110
  },
  {
    "text": " modifying these ﬁles by hand or programmatically without knowing precisely what you are doing will most likely damage your KiCad project. Always back up your work before any such experimentation! The Tools dropdown menu gives you access to the individual apps in the KiCad software suite. The items in this menu replicate the application buttons in the right pane of the KiCad main window. Figure 2.2.8: The Tools menu items. I will describe these applications in the next chapter. Under Preferences (not to be confused with the Preferences window under \"KiCad\"), you can access the Paths, Symbol Libraries, and Footprint Libraries manager windows. 62 Figure 2.2.9: The Preferences menu. I have written a dedicated chapter on these manager windows with details later in this Part of the book. Finall",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 111
  },
  {
    "text": "ten a dedicated chapter on these manager windows with details later in this Part of the book. Finally, the help menu. It allows you to access a local copy of the ofﬁcial KiCad documentation, which opens in your browser, and a window that contains a list of hotkeys. Be mindful that this documentation may be old. When I am writing this, this documentation has not been updated since KiCad 5.0.0-rc2, and most of the links are not working. The Hotkeys window, apart from listing current hotkeys, allows you to make changes. I prefer to keep the default hotkeys unless there is a conﬂict with other applications running on my computer. This was an overview of the main KiCad window, the KiCad project manager. In the next chapter, you will learn about the individual applications that make up the KiCad",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 112
  },
  {
    "text": "anager. In the next chapter, you will learn about the individual applications that make up the KiCad software suite. 63 3. Overview of the individual KiCad apps In the previous chapter, you learned about the KiCad Project Manager. This chapter will give you a tour of the individual applications that make up the KiCad software suite. As you may recall from the previous chapter, you can access the KiCad applications via the project manager’s right pane or the Tools menu. To open Eeschema or Pcbnew, you can also double-click on the schematic and layout ﬁles listed on the middle page of the project manager. Let’s take a closer look at each of the KiCad applications. Schematic editor: Eeschema Click on the Schematic Editor button to open the application. You can see the editor window below. Fig",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 113
  },
  {
    "text": "ick on the Schematic Editor button to open the application. You can see the editor window below. Figure 2.3.1: Eeschema, or the Schematic Editor. You use Eeschema to draw the schematic of the PCB. Although KiCad is ﬂexible enough and allows you to create PCBs without a schematic, this is rarely a good idea. The schematic diagram captures all necessary information that the layout editor uses: components (as symbols), wires that connect pins, 64 nets, and various kinds of netlabels, busses, power nets, and much more. Eeschema is the ﬁrst KiCad application you will use when you start a new KiCad project. In the example above, you can see a schematic from one of the projects in this book. You can see the symbols (such as U2, R1, and R2), green wires connecting pins, special symbols representin",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 114
  },
  {
    "text": "n see the symbols (such as U2, R1, and R2), green wires connecting pins, special symbols representing unconnected pins and power nets, and other elements like graphics and text labels. You can learn how to use and conﬁgure the schematic editor in a dedicated Part of this book. Layout editor: Pcbnew Once you have completed work in Eesceham, you will continue with the Layout editor, or “Pcbnew.” To open Pcbnew, you can click on the Pcbnew button in the KiCad project manager or the Pcbnew button in the top toolbar of Eesceham. Below you can see an example instance of Pcbnew. Figure 2.3.2: Pcbnew, or the Layout Editor. In the example above, you can see the ﬁnished PCB design from one of the projects in this book. The layout editor allows you to select the layers and design elements you want to",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 115
  },
  {
    "text": "ects in this book. The layout editor allows you to select the layers and design elements you want to see. For example, you can enable or disable the visibility of layers, footprints, tracks, zones, and vias. In the example above, I have enabled the visibility of all layers and elements and an outline of the top and bottom copper zones. 65 The layout editor includes various sophisticated tools, such as an interactive router and a 3D viewer. You can see a 3D rendering of the PCB from Figure Figure 2.3.2 below: Figure 2.3.3: The 3D viewer in Pcbnew. You can learn how to use and conﬁgure the layout editor in a dedicated Part of this book. Symbol Editor Let’s continue with the Symbol Editor. You can open this application from the KiCad Project Manager or the top toolbar of Eeschema. 66 Figure 2",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 116
  },
  {
    "text": "can open this application from the KiCad Project Manager or the top toolbar of Eeschema. 66 Figure 2.3.4: The Symbol Editor. With the Symbol Editor, you can modify existing symbols or create new ones. You can think of the Symbol Editor as a simpliﬁed version of the schematic editor. In the Symbol Editor, you can work with a single symbol at a time. KiCad 6 comes with an extensive set of symbol and footprint libraries. There are also thousands of third-party symbols and footprints that you can import. However, you will eventually need to create a symbol, and that’s when the Symbol Editor comes in. You can learn how to create new symbols from scratch later in this book. Footprint editor Similar to the symbol editor, there is also the footprint editor. You can open the footprint editor from t",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 117
  },
  {
    "text": "r to the symbol editor, there is also the footprint editor. You can open the footprint editor from the KiCad project window or the Pcbnew top toolbar. 67 Figure 2.3.5: The Footprint Editor. With the footprint editor, you can create a footprint from scratch or modify an existing footprint. The footprint editor also contains a wizard that allows you to quickly generate footprints that follow convention, such as those that use BGA, QFN, DIP and SOIC, packages. You can learn how to use the footprint editor in a dedicated chapter. Gerber Viewer When you have completed work on your PCB and wish to order it from an online manufacturer, the most common way is to export a set of Gerber ﬁles from Pcbnew. Before you upload those ﬁles to your preferred manufacturer, you should take the time to inspect",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 118
  },
  {
    "text": "ew. Before you upload those ﬁles to your preferred manufacturer, you should take the time to inspect them. KiCad has a tool for this: the Gerber Viewer. Figure 2.3.6: The Gerber Viewer. 68 With the Gerber Viewer, you can examine the project Gerber ﬁles visually, layer by layer. This way, you can ensure that all its elements are correct. Silkscreen text and graphics, drills, copper ﬁlls, the board outline, and cutouts, etc. Think of the Gerber Viewer as a quality control tool. Use it to reduce or eliminate the risk of ordering a defective PCB. You can learn how to export the Gerber ﬁles and use the Gerber Viewer (and online Gerber viewers) in dedicated chapters later in this book. Image Converter You can open the image converter app from the KiCad Project Manager. With the Image converter, ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 119
  },
  {
    "text": "rter You can open the image converter app from the KiCad Project Manager. With the Image converter, you can convert a bitmap image into a footprint. Typical uses of the converter are to create a graphics footprint (such as a company logo) or a footprint with an irregular shape that would be too tedious to design in the footprint editor. Figure 2.3.7: The Image Converter. In the example above, I use the Image Converter to create a logo that I can include in my PCBs. You can learn how to use the Image converter in a dedicated chapter in Part 13 of this book. Calculator tools The calculator tool contains multiple calculators. Here is a list of tools: 1. Voltage regulators. 2. RF Attenuators. 69 3. E-Series. 4. Resistor color codes. 5. Transmission lines. 6. Via size. 7. Track Width. 8. Electr",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 120
  },
  {
    "text": " 3. E-Series. 4. Resistor color codes. 5. Transmission lines. 6. Via size. 7. Track Width. 8. Electrical spacing. 9. Board classes. In the example below, I am using the Track Width calculator to calculate the correct width given a set of parameters. Figure 2.3.8: The Calculator tool. You can learn how to use the Track Width calculator by reading the relevant chapter in the Recipes part of this book. The mode of operation for the rest of the calculators is similar. Drawing Sheet editor The last main application in the KiCad suite is the Drawing Sheet editor. You can use this editor to customize your schematic editor sheet. You can see the editor in the example below. 70 Figure 2.3.9: The Drawing Sheet editor. With the Drawing Sheet Editor, you can change the size of the schematic sheet and ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 121
  },
  {
    "text": "ing Sheet editor. With the Drawing Sheet Editor, you can change the size of the schematic sheet and everything within it. For example, you can remove or change the size and location of the information container. You can also change the setup of the text placeholders inside the information box. To learn how to use the Drawing Sheet Editor, please read the relevant chapter in the Recipes part of this book. 71 4. Paths and Libraries In the KiCad project window, you will ﬁnd the paths and libraries conﬁgurations options under the preferences menu item. Figure 2.4.1: The Preferences menu. Let’s look at each one. Conﬁgure Paths Bring up the “Conﬁgure Paths” window from the Preferences menu. This window contains a table to environment variables that contain paths to important collections of ﬁles.",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 122
  },
  {
    "text": "indow contains a table to environment variables that contain paths to important collections of ﬁles. Figure 2.4.2: The “Conﬁgure Paths” window. 72 As you can see in the ﬁgure above, there are ﬁve path environment variables: ◦ ◦ ◦ ◦ ◦ ◦ KICAD6 3DMODEL DIR: points to a directory that contains 3D models of components for use by the 3D viewer. Learn more about this in a dedicated chapter. KICAD6 3RD PARTY: points to a directory that contains 3rd party plugins, libraries, and other downloadable content. KICAD6 FOOTPRINT DIR: points to a directory that contains footprint ﬁles for use by Pcbnew. Learn more about this in a dedicated chapter. KICAD6 SYMBOL DIR: points to a directory that contains symbol ﬁles for use by Eeschema. Learn more about this in a dedicated chapter. KICAD6 TEMPLATE DIR: poi",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 123
  },
  {
    "text": "bol ﬁles for use by Eeschema. Learn more about this in a dedicated chapter. KICAD6 TEMPLATE DIR: points to a directory that contains sheet template ﬁles for use by Eeschema. Learn more about this in a dedicated chapter. KICAD USER TEMPLATE DIR: points to a directory that contains project template ﬁles created by the user. You can use these template ﬁles to start a new project quickly. Learn more about this in a dedicated chapter. When you install KiCad, these variables will inherit default values that point to the KiCad application installation folder. You can use the Conﬁgure Paths window to change these values. For example, my computer has a solid-state drive with a limited amount of available space on it. Because the libraries (especially the 3D models) take several gigabytes of storage",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 124
  },
  {
    "text": "able space on it. Because the libraries (especially the 3D models) take several gigabytes of storage, I have opted to use my external RAID drive for those resources. As you can see in Figure 2.4.2 above, the footprint, symbol, and 3D model paths point to my external RAID drive, while the rest point to locations on the internal SSD. Manage Symbol Libraries Use the symbol libraries manager to: • Add new symbol libraries. • Delete symbol libraries. • Activate or deactivate symbol libraries. 73 The Symbol Libraries window contains a list of active or inactive libraries installed in your KiCad instance. Each library may contain one or more schematic symbols. When a library is installed and activated, you can use its symbols in your schematics in Eeschema. Figure 2.4.3: The “Symbol Libraries” wi",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 125
  },
  {
    "text": "ted, you can use its symbols in your schematics in Eeschema. Figure 2.4.3: The “Symbol Libraries” window. In the ﬁgure above, you can see the Symbol Libraries window with several of the libraries installed in my instance of KiCad. ◦ ◦ Notice that: The table contains two tabs: “Global Libraries” and “Project Speciﬁc Libraries.” You can manage libraries under each tab to control the library visibility (global or project-speciﬁc). Each library has a name and a path. The path can use an environment variable, as in the example above. Alternatively, you can set an absolute path to a library; this is often a good option when you want to install a library stored outside the standard environment paths. ◦ If you forget the environment variable paths, look at the bottom of the window. In the table “P",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 126
  },
  {
    "text": "s. ◦ If you forget the environment variable paths, look at the bottom of the window. In the table “Path Substitutions,” you can see the actual path stored in the environment variables. Learn how to use the symbol libraries manager in a dedicated chapter later in this book. 74 Manage Footprint libraries Use the footprint libraries manager to: • Add new footprint libraries. • Delete footprint libraries. • Activate or deactivate footprint libraries. The footprint libraries manager window works similarly to the symbol libraries manager. Figure 2.4.4: The “Footprint Libraries” window. You can control the context of a library by listing them under the “Global Libraries” or “Project Speciﬁc Libraries” tab. Each library has a name and a path, and the path may contain an environment variable or an ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 127
  },
  {
    "text": "es” tab. Each library has a name and a path, and the path may contain an environment variable or an absolute path. Learn how to use the footprint libraries manager in a dedicated chapter later in this book. 75 5. Create a new project from scratch In this chapter, you will learn how to create a new KiCad project. Kicad offers you two ways to start a new project: 1. A new blank project. 2. A new project from a template. Figure 2.5.1: KiCad offers two ways to start a new project. When you start a new project from a template, you can take advantage of work that you (or the original author of the template) have done in the past. Project templates offer an excellent way to speed up the initial time- consuming steps for projects that share a common base. For example, if you create Arduino shields",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 128
  },
  {
    "text": "e- consuming steps for projects that share a common base. For example, if you create Arduino shields, you can set up an Arduino shield base template and use it to create new Arduino shield projects. You can learn more about project templates in a dedicated chapter in the Recipes part. In this chapter, you will create a new blank project. In the File menu, click on “New Project…”. In the window that appears, set a name (“1”, below), check the new folder box to have KiCad automatically create a new folder for your project (“2”), and click Save (“3”). 76 Figure 2.5.2: Set a name and directory for the new project. KiCad will set up your new project. In the project folder, you will see three new ﬁles: 1. The main project ﬁle with extension “.kicad pro.” 2. The schematic design ﬁle with extensio",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 129
  },
  {
    "text": "ﬁles: 1. The main project ﬁle with extension “.kicad pro.” 2. The schematic design ﬁle with extension “.kicad sch.” 3. The layout design ﬁle with extension “.kicad pcb.” The KiCad project window will show the project as a hierarchy tree. At the top of the hierarchy is the project ﬁle (“.kicad pro”), and inside of that are the schematic and layout ﬁles. Figure 2.5.3: The new project is ready. At this point, your new project is ready. You can open the schematic editor and begin work on the schematic. This is where you will begin work in the next part of this book, in which you will work on your ﬁrst KiCad project. In the next chapter, you will learn how to create a new KiCad project from a template. 77 6. Create a new project from a template In this chapter, you will learn how to create a ne",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 130
  },
  {
    "text": "plate. 77 6. Create a new project from a template In this chapter, you will learn how to create a new project from a template. KiCad comes with several project templates ready to use, but you can also create yours. You can read a dedicated chapter in the Recipes part if you are interested in creating custom project templates. Click on “New Project from Template” in the File menu to create a new project from a template. The project templates window will appear (see below). Figure 2.6.1: The project templates selector. The selector window contains two tabs: System Templates and User Templates. 78 In a new KiCad installation, the User Templates tab will be empty until you create a new template and store it in the appropriate template directory (learn how to do this in the relevant chapter in ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 131
  },
  {
    "text": "and store it in the appropriate template directory (learn how to do this in the relevant chapter in the Recipes part). The System Templates tab shows a collection of built-in templates. Click on a template icon to see information about it. For this example, I have selected one of the Raspberry Pi templates. The information box shows a description of the template. The description is composed of regular HTML so that you can include text, links, and images. After selecting the template, you want to use, click OK. This will bring up the Save dialog box. This is identical to the dialog box that appears when you create a new blank project. Give the new project a name and location, and click Save. Figure 2.6.2: The name and location of the new project. When KiCad ﬁnished creating the new project ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 132
  },
  {
    "text": "Figure 2.6.2: The name and location of the new project. When KiCad ﬁnished creating the new project from the Raspberry Pi template, you will see several new ﬁles in the project folder (right, below) and the project hierarchy in the KiCad project window (left, below). Figure 2.6.3: The new project created from a project template. 79 In the project folder (above, right), notice that several additional ﬁles also appear in addition to the project, schematic, and layout ﬁles. These additional ﬁles have been copied from the Raspberry Pi project template. In the KiCad project window, click on the Schematic Editor button to open Eeschema. In a new blank project, the schematic editor is empty. But this is a new project from a template; the schematic and layout editors are already populated with see",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 133
  },
  {
    "text": "is is a new project from a template; the schematic and layout editors are already populated with seeding content. Below is the schematic editor showing a header and mounting holes for a Raspberry Pi project: Figure 2.6.4: The new project schematic is already populated with content from the template. Similarly, the layout editor is already populated with content from the template: 80 Figure 2.6.5: The new project layout is already populated with content from the template. As you can see, much of the work has already been done. In the layout editor, the design of the board outline requires exact measurements, which are time-consuming. The placement of the mounting holes and connectors, likewise, must be exact and, as a result, very time-consuming. All this is work that you can avoid when you",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 134
  },
  {
    "text": "e, must be exact and, as a result, very time-consuming. All this is work that you can avoid when you create a new project from a template. Creating a new project from a template is an example of a productivity- boosting tool that KiCad provides. You will learn about many more in this book. 81 7. KiCad 6 on Mac OS, Linux, Windows KiCad has supported multiple operating systems from its early days. When I started using KiCad in version four, I used it on Windows, Mac OS, and Linux (Ubuntu). However, there were differences between those platforms, both in terms of reliability (I found Windows, generally, worked better) and how the user interface looked and behaved. I have been using KiCad 6 almost daily for almost nine months now, and I feel that KiCad works seamlessly on the three operating s",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 135
  },
  {
    "text": "st daily for almost nine months now, and I feel that KiCad works seamlessly on the three operating systems I have used (Mac OS, Windows 10, and Linux). I spent a lot of time comparing the two. My testing consisted of a single project that I opened and edited across the three operating systems. I used KiCad's ”archive project” function, which you can ﬁnd under \"File\" in the KiCad project window. Opening and working on a project that I previously edited on a different operating system were trouble-free. Below, you can see the same project's main KiCad project window in Mac OS, Windows, and Kubuntu. They look identical while following the UI conventions of their host operating system. 82 Figure 2.7.1: KiCad project window on three OSs. There were no surprises in terms of KiCad's main applicat",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 136
  },
  {
    "text": " 2.7.1: KiCad project window on three OSs. There were no surprises in terms of KiCad's main applications, Eeschema and Pcbnew, and how those work. Shortcuts, mouse conventions, menus, buttons, colors; all work as expected in a truly cross-platform compatible application suite. Below is an example of Eeschema in the three operating systems: 83 Figure 2.7.2: Eeschema in the three OSs. And here is Pcbnew: 84 Figure 2.7.3: Pcbnew in the three OSs. The same uniformity appears when testing other KiCad applications, such as the 3D viewer, the various preferences windows, and the interactive router. Even secondary widgets and features work well across the supported platforms. 85 Figure 2.7.4: Schematic Setup in Mac OS and Windows. The quality of the implementation of Kicad in the three operating s",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 137
  },
  {
    "text": "tic Setup in Mac OS and Windows. The quality of the implementation of Kicad in the three operating systems I have tested is excellent. The implication for solo users and teams is that you can use KiCad 6 with high conﬁdence that you can edit the same projects across platforms. If you are in a team, your team members will work using their preferred operating system. 86 8. Differences between KiCad 6 and 5 KiCad 6 is a signiﬁcant upgrade over KiCad 5. If you are new to KiCad, and KiCad 6 is the ﬁrst KiCad you have ever used, you can safely ignore this chapter. Go ahead to Part 3, and begin work on your ﬁrst KiCad project. However, if you have used a previous version of KiCad and created one or more projects, you take some time to read a blog post that I wrote in early 2021. In that blog post",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 138
  },
  {
    "text": " more projects, you take some time to read a blog post that I wrote in early 2021. In that blog post, I go into detail to highlight and explain the differences between KiCad 6 and KiCad 5. Figure 2.8.1: Peter’s Big KiCad 6 review. Here, I will list my top-three most signiﬁcant changes in KiCad 6: 1. KiCad 6 has a new ﬁle format. The transition into this format, based on the S-Expressions standard, started in KiCad 5. With KiCad 6, the transition is complete. 2. The user interface is refreshed and modernized. While in KiCad 6, the user interface is still recognizable from the earlier versions, it follows 87 modern conventions on how the mouse and keyboard work. If you are coming from an earlier version of KiCad, you will use your existing KiCad knowledge. Icons have been redesigned. The men",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 139
  },
  {
    "text": "er version of KiCad, you will use your existing KiCad knowledge. Icons have been redesigned. The menus and toolbars are better placed and organized. There is a single Preferences window. 3. The schematic editing paradigm is updated. Now, when you click on an element in the schematic editor, the element is selected. This was not the case in KiCad 5 and prior, causing much confusion and frustration. Get the full details of what’s new in KiCad 6 in my comprehensive blog post. 88 Part 3: Project - A hands-on tour of KiCad - Schematic Design 89 1. Introduction to schematic design and objective of this section In Part 3 of the book (which you are reading now), you will learn about the basics of KiCad by working and completing a simple PCB project. In Part 3, the focus is on the schematic design,",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 140
  },
  {
    "text": "Cad by working and completing a simple PCB project. In Part 3, the focus is on the schematic design, while in Part 4, the focus shifts to the layout design and the manufacturing. By the end of this project, you will have experienced the PCB design process using KiCad from start to ﬁnish. While this ﬁrst project is relatively simple, it will teach you the most important KiCad features and tools. You will develop skills that you will use in every future project regardless of its complexity. As you work your way through this project, remember that you may need to reference the chapters in Part 13, Recipes, if you want to learn more details about speciﬁc features. To keep the size of the project concise, I have moved detailed descriptions of various features and tools to the end of the book. T",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 141
  },
  {
    "text": " concise, I have moved detailed descriptions of various features and tools to the end of the book. The practical objective of this project is to design and manufacture a simple LED torch, like the one you see in 3.1.1 (below): Figure 3.1.1: The manufactured project deliverable. Most of the work will be in Eeschema (the schematic design editor) and Pcbnew (the layout design editor). At the end of this Part 3 of the book, the schematic design will look like this (Figure 3.1.2): 90 Figure 3.1.2: The ﬁnal project schematic design. The ﬁnal layout will look like this (Figure 3.1.3): Figure 3.1.3: The ﬁnal project layout design. To guide the design of the PCB, I will be using the PCB design workﬂow that I outlined earlier in this book. I am also providing a summary in the next chapter. The schem",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 142
  },
  {
    "text": "w that I outlined earlier in this book. I am also providing a summary in the next chapter. The schematic (see Figure 3.1.2) contains only a few standard component symbols: an LED, a resistor, a button switch, and a battery holder. All these symbols are available in the KiCad libraries, so you will not need to get them 91 from external sources. Electrically, the circuit contains a single loop. When you press the button, the circuit closes, and the LED turns on. Despite this being a simple project, you will learn how to ﬁnd and add symbols to the editor, associate them with layout footprints, annotate them, wire them, create named nets, run the Electrical Rules Checker, and decorate the schematic with text and graphics. In Part 4, you will learn how to import the schematic in Pcbnew and desi",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 143
  },
  {
    "text": "tic with text and graphics. In Part 4, you will learn how to import the schematic in Pcbnew and design the physical layout, complete with beautifully rounded corners, mounting holes, silkscreen graphics, and, of course, pass the design rules check before sending it to manufacturing. 92 Part 4: Project- A hands-on tour of KiCad - Layout 93 1. Introduction to layout design and objective of this section In the chapters of this part of the book, I will continue developing the LED torch project that I started in Part 3. At the end of the previous chapter, I completed the schematic design of the project PCB. I will now continue with the layout design. To guide me with this work, I will follow the steps outlined in the layout design workﬂow that I outlined in Part 3. To design the layout of the P",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 144
  },
  {
    "text": "steps outlined in the layout design workﬂow that I outlined in Part 3. To design the layout of the PCB, I’ll be using Pcbnew. At the end of this part of the book, the PCB will look like this (Figure 4.1.1): Figure 4.1.1: The ﬁnal LED torch PCB layout. Here is a 3D rendering, also made in KiCad (Figure 4.1.2): 94 Figure 4.1.2: The ﬁnal LED torch PCB layout in 3D. The ﬁnal PCB layout of this simple project contains several interesting elements: \" \" \" Both surface-mounted and through-hole components. Rounded edges moulded around the footprints of the PCB components. Silkscreen graphics (logos) and text. Even though this is a simple project, it allows us to practice the essential skills for PCB design using KiCad. Let’s begin the layout design workﬂow with Pcbnew in the next chapter. 95 Part 9",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 145
  },
  {
    "text": "design using KiCad. Let’s begin the layout design workﬂow with Pcbnew in the next chapter. 95 Part 9: Project - Design a simple breadboard power supply PCB 96 1. Introduction Welcome to Part 9 of this book! In the following chapters, you will learn how to design a simple yet practical PCB. This PCB is a component of a breadboard power supply. You can use this power supply to provide power to circuits implemented on a mini breadboard, which is a core part of electronics prototyping. This project is an opportunity to use the knowledge you acquired in the last part of this book to create a non-trivial PCB. To design this PCB, you will be using the majority of the capabilities of KiCad’s schematic and layout editors. You will also practice the PCB development workﬂow that you learned in Part 6",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 146
  },
  {
    "text": "ic and layout editors. You will also practice the PCB development workﬂow that you learned in Part 6 of the book. The inspiration for the design of this PCB came from my work at creating small electronics circuits for my Arduino and ESP32 courses. When the circuit I was building on the breadboard needed more power than the MCU could provide, I would search through a range of possible options that usually included one of my bench-top power supplies and wires. The problem is that the bench-top power supplies are noisy (they have a large cooling fan), need some setup (select voltage, current), and their wires get in the way. In addition, I have drawers full of wall power supplies that I could be using. They are plug-and-play and silent. For my breadboard power supply, I needed something that:",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 147
  },
  {
    "text": "e using. They are plug-and-play and silent. For my breadboard power supply, I needed something that: 1. Plugs directly on the breadboard; therefore, there are no wires. 2. Have an on/off switch. 3. Can provide 5V and 3.3V power. 4. Can draw power from a range of wall power supplies, from 6V to 12V. After some deliberation, I settled for a design like the one in the image below: 97 Figure 9.1.1: A 3D view of the breadboard power supply PCB. The PCB’s dimensions and shape are constrained by the dimensions of power row locations of the mini breadboard on which the PCB will connect. The connection between the breadboard and the PCB is made via two sets of pin headers. I have added two double screw terminals to provide an additional way to output power via jumper wires instead of the pins. Belo",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 148
  },
  {
    "text": "ew terminals to provide an additional way to output power via jumper wires instead of the pins. Below you can see a photo that shows the PCB against a mini breadboard: Figure 9.1.2: The power supply PCB over a mini breadboard. 98 When the PCB is attached to the left side of the breadboard, almost the entire right side is available for the prototyping circuit. The indentation between the pin headers also allows access to the ﬁrst couple of columns in the breadboard that otherwise would have been covered. To keep the power supply cable away from the prototyping area, I have placed the barrel connector on the left side of the PCB. The voltage selector switches are on the top and bottom of the board to make it easy to access. Below you can see the ﬁnal schematic design: Figure 9.1.3: The proje",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 149
  },
  {
    "text": "oard to make it easy to access. Below you can see the ﬁnal schematic design: Figure 9.1.3: The project schematic design (ﬁnal). In the schematic above, you can see the power supply components arranged in three functional groups. You can see the two major components, the voltage regulators, inputs, outputs, and switches. You will work on the schematic design in the next chapter. We’ll do the schematic design in a single sheet. Most of the symbols needed come with KiCad’s libraries, but one is available in the Digikey library. Below, you can see the ﬁnal layout design: 99 Figure 9.1.4: The project layout design (ﬁnal). The layout has several interesting features, including a composite shape with rounded corners, copper ﬁlls, all THT components to make it easy to assemble, a complete set of t",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 150
  },
  {
    "text": "th rounded corners, copper ﬁlls, all THT components to make it easy to assemble, a complete set of top and bottom silkscreen text and graphics, and is manually routed. Perhaps the most challenging aspect of the layout design is its dimensions. The PCB’s pin headers have to match precisely with the mini breadboard’s power row pins. To achieve a good match, you will need to make accurate measurements on the breadboard and then use those measurements to precisely position the two double pin headers. Then you will design the board around those ﬁxed footprints. Below you can see the Bill of Materials for this project, as I have extracted it from the KiCad project (learn how later in this book): Referenc Value Footprint e C1 10u Capacitor THT:C Disc D3.0mm W1.6m m P2.50mm 100 C2 C3 D1 J1 J2, J5 ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 151
  },
  {
    "text": "eferenc Value Footprint e C1 10u Capacitor THT:C Disc D3.0mm W1.6m m P2.50mm 100 C2 C3 D1 J1 J2, J5 1u 0.1u LED Capacitor THT:C Disc D3.0mm W1.6m m P2.50mm Capacitor THT:C Disc D3.0mm W1.6m m P2.50mm LED THT:LED D5.0mm Barrel Jack Switch Connector BarrelJack:BarrelJack Horizo ntal Screw Terminal 01x TerminalBlock:TerminalBlock bornier-2 02 P5.08mm J4, J6 Conn 01x02 Male J3, J7 Conn 01x03 Male R1, R2 330 560 Connector PinHeader 2.54mm:PinHead er 1x02 P2.54mm Vertical Connector PinHeader 2.54mm:PinHead er 1x02 P2.54mm Vertical Resistor THT:R Axial DIN0204 L3.6m m D1.6mm P7.62mm Horizontal Resistor THT:R Axial DIN0204 L3.6m m D1.6mm P7.62mm Horizontal digikey- EG1218 footprints:Switch Slide 11.6x4mm EG12 LM317 TO-220 LM7805 TO220 18 Package TO SOT THT:TO-220-3 Vertica l Package TO SOT THT:TO-",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 152
  },
  {
    "text": "6x4mm EG12 LM317 TO-220 LM7805 TO220 18 Package TO SOT THT:TO-220-3 Vertica l Package TO SOT THT:TO-220-3 Vertica l R3 S1 U1 U2 Table 9.1.1: The Bill of Materials for this project. Let’s begin with the schematic design in the next chapter. 101 Part 10: Project - A 4 x 8 x 8 LED matrix array 102 1. Introduction Welcome to Part Ten! In the chapters that follow, you will design a PCB that can hold four 8x8 LED matrix displays controlled by an Arduino Pro mini. The board also includes two push buttons to which you can assign arbitrary functions. I plan to use mine as a Pomodoro timer. I will use one button to select the lap duration (say, 15, 20, or 25 minutes) and the other button to reset the timer. When the duration I have set expires, the display will blink to let me know. You can see the ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 153
  },
  {
    "text": "timer. When the duration I have set expires, the display will blink to let me know. You can see the two sides of the populated PCB in the photograph below: Figure 10.1.1: The PCB in this project, populated. The inspiration for this project is that I forget to get up from my desk at regular intervals. I could use a desktop or phone Pomodoro app or even a classic mechanical Pomodoro timer, but why buy one when I can make one? I decided to use an Arduino Pro Mini because: \" \" I have a lot of them. They are easy to ﬁnd in the market 103 \" \" \" \" \" They are very cheap. They are small. They have an onboard regulator. They are accurate enough to count short periods. I don’t need a clock function, so the absence of a real-time clock is not an issue. This board does not contain a UART to USB interfa",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 154
  },
  {
    "text": " the absence of a real-time clock is not an issue. This board does not contain a UART to USB interface, so you must provide an external bridging device. This device is required for programming the microcontroller. I use a USD to serial adaptor from Freetronics, but there are many other options in the market. I decided to use the 8x8 LED matrix display module because I like its versatility. An 8x8 LED matrix display can show numbers, text, and simple graphics compared. I also like the way it looks from a distance and the ability to create simple animation. All this gives me scope to add features to my Pomodoro project in the future. Below you can see the schematic for this PCB. This is the schematic you will create by the end of Chapter 10.2. Figure 10.1.2: The project schematic. To draw th",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 155
  },
  {
    "text": "hematic you will create by the end of Chapter 10.2. Figure 10.1.2: The project schematic. To draw this schematic, I have opted to use line wires for all pins that are nearby. I have added net labels to all power, data, clock nets, and button signal nets. I was unable to ﬁnd a schematic symbol for the Arduino Pro Mini board that I planned to use, so I created one, along with its matching 104 footprint. In the layout, I have included four mounting holes. To avoid getting error messages from the DRC, I have associated the mounting hole footprints with mounting hole symbols in the schematic. Another consideration was how to deal with the LED matrix modules. I was not able to ﬁnd a symbol and footprint for this device, so I had two options: 1. Create a custom symbol and footprint, as I did with",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 156
  },
  {
    "text": "tprint for this device, so I had two options: 1. Create a custom symbol and footprint, as I did with the Arduino Pro Mini module. 2. Ignore the module, and concentrate on the headers. Since I went with option 1 for the Arduino module, I opted for option 2 for the LED modules. Instead of treating each LED module as a single device, I treated it as a set of two-pin headers. My objective, then, was to wire the header symbols correctly and place their footprints precisely on the PCB (see the discussion on the PCB below). Below is the layout of the PCB, as it will be at the end of Chapter 10.3: Figure 10.1.3: The project layout. The dominating feature of this board is its shape. I wanted to experiment with a shape that uses “arms” that extend from its center to hold the LED modules rather than ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 157
  },
  {
    "text": "iment with a shape that uses “arms” that extend from its center to hold the LED modules rather than a conventional rectangular shape. I did not do this to reduce the manufacturing cost. Even though the shape you see above has two signiﬁcant parts of the substrate material removed, the manufacturing cost relates to the all-inclusive height and width of the board (you can see those dimensions in the ﬁgure above). But I do think that the board with the four arms extending from the center looks great. Along with the rounded edges and the button notch at the bottom, I am satisﬁed with the physical design aspect of the board. 105 A signiﬁcant challenge for the layout design of this board is the position of the pin headers for the LED modules. As I mentioned above, I decided to treat the LED modu",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 158
  },
  {
    "text": "sition of the pin headers for the LED modules. As I mentioned above, I decided to treat the LED modules as a set of two headers each (input and output). The positions of those headers must be very accurate. If the headers are too far from their neighbors, the four-module display will not look continuous but as four individual displays. If they are too close, the assembly will not be possible as there will not be enough space on the board to attach adjacent modules. As a result, this project will give you the opportunity to use all of KiCad’s measurement and alignment tools to make sure that the end product looks beautiful and works. Below you can see the Bill of Materials for this project, as I have extracted it from the KiCad project (learn how later in this book): Referen Value Footprint",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 159
  },
  {
    "text": "s I have extracted it from the KiCad project (learn how later in this book): Referen Value Footprint ce H1-H4 MountingHole Barrel Jack Connector BarrelJack:BarrelJack Horizontal J1 J2 J3 J4 J5 J6 J7 J8 J9 LED1 IN LED1 OUT LED2 IN LED2 OUT LED3 IN LED3 OUT LED4 IN LED4 OUT R1, R2 10K MountingHole:MountingHole 2.5mm Connector PinHeader 2.54mm:PinHeader 1 x05 P2.54mm Vertical Connector PinHeader 2.54mm:PinHeader 1 x05 P2.54mm Vertical Connector PinHeader 2.54mm:PinHeader 1 x05 P2.54mm Vertical Connector PinHeader 2.54mm:PinHeader 1 x05 P2.54mm Vertical Connector PinHeader 2.54mm:PinHeader 1 x05 P2.54mm Vertical Connector PinHeader 2.54mm:PinHeader 1 x05 P2.54mm Vertical Connector PinHeader 2.54mm:PinHeader 1 x05 P2.54mm Vertical Connector PinHeader 2.54mm:PinHeader 1 x05 P2.54mm Vertical Resi",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 160
  },
  {
    "text": "mm:PinHeader 1 x05 P2.54mm Vertical Connector PinHeader 2.54mm:PinHeader 1 x05 P2.54mm Vertical Resistor THT:R Axial DIN0204 L3.6mm D1 .6mm P7.62mm Horizontal 106 S1, S2 1825967-1 1825967-1:SW 1825967-1 S3 U1 SS12D07VG4 SS12D07VG4:SW SS12D07VG4 ArduinoProMiniS imple DesktopLibrary:ArduinoProMiniCustom Table 10.1.1: The Bill of Materials for this project. Apart from the custom symbol and footprint Arduino Pro Mini, I used Snapeda to ﬁnd the symbol-footprint pairs for the two buttons (S1 and S2) and the power barrel connector (S3). Let’s begin with the schematic design in the next chapter. 107 Part 11 : Project - MCU datalogger 108 1. Project - Introduction Welcome to Part 11. In this Part, you will design a printed circuit board for a microcontroller data logger. The data logger is based on",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 161
  },
  {
    "text": "u will design a printed circuit board for a microcontroller data logger. The data logger is based on an Atmega 328P-AU microcontroller and is supported by two EEPROMs and a real-time clock. Additional components on the board, such as status LEDs with their supporting resistors, two crystal oscillators, connectors, and capacitors. You will use SMD packages for most components on a rectangular two- layer board with mounting holes on the four corners. The project highlights are: 1. You will use Git to capture the history of the project’s development. 2. You will design two versions of the PCB: one with two layers and one with four layers. Both will use data from the same schematic design. KiCad, on its own, does not allow the creation of more than one layout for a schematic. Git makes this po",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 162
  },
  {
    "text": ", on its own, does not allow the creation of more than one layout for a schematic. Git makes this possible with the use of branches. This project will allow you to practice this aspect of Git-powered PCB design with KiCad. The schematic design contains components distributed across two sheets. You can see the ﬁnal schematic below (sheet 1): Figure 11.1.1: Sheet 1 of the project’s ﬁnal schematic design. 109 In Sheet 1, I have placed the main components of the board. Sheet 2 contains the connectors: Figure 11.1.2: Sheet 2 of the project’s ﬁnal schematic design. In the schematic design, I have used a combination of line wires and net labels. Other than the distribution of the components across the two sheets, the techniques I have used to draw the schematic should be familiar to you from prev",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 163
  },
  {
    "text": "the two sheets, the techniques I have used to draw the schematic should be familiar to you from previous projects. The most exciting aspect of this project is the layout design: you will design two versions of the PCB. A two-layer and a four-layer version. You can see the ﬁnal version of the two-layer PCB layout below: Figure 11.1.3: The project’s ﬁnal layout design (two layers). You can see the ﬁnal four-layer PCB below: 110 Figure 11.1.4: The project’s ﬁnal layout design (four layers). The main objectives of this project are: 1. To help you practice skills you acquired in previous projects. 2. To use Git in a non-trivial project to extend KiCad’s use cases in a single-schematic and multi-layout project. 3. To gain experience in creating multi-layer PCBs. Below you can see the Bill of Mat",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 164
  },
  {
    "text": "ayout project. 3. To gain experience in creating multi-layer PCBs. Below you can see the Bill of Materials for this project, as I have extracted it from the KiCad project (learn how later in this book): Re Value Footprint ference BT 1 C1 , C4 C2 , C3 C5 D1 , D2 H1 -H 4 J2 Battery Connector PinHeader 2.54mm:PinHea der 1x02 P2.54mm Vertical 0.1uF Capacitor SMD:C 0805 2012Metric 22pF 100nF LED Capacitor SMD:C 0805 2012Metric Capacitor SMD:C 0805 2012Metric LED SMD:LED 0805 2012Metric MountingHol e Conn 01x09 Male MountingHole:MountingHole 2.1mm Connector PinHeader 2.54mm:PinHea der 1x09 P2.54mm Vertical 111 J1 , J3 J4 R1 , R2 , R6 R3 , R4 R5 , R7 U2 U1 , U3 U4 Y1 Y2 Conn 01x04 Male Conn 02x03 Odd Even Connector PinHeader 2.54mm:PinHea der 1x04 P2.54mm Vertical Connector PinHeader 2.54mm:PinHe",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 165
  },
  {
    "text": "dd Even Connector PinHeader 2.54mm:PinHea der 1x04 P2.54mm Vertical Connector PinHeader 2.54mm:PinHea der 2x03 P2.54mm Vertical 10K Resistor SMD:R 0805 2012Metric 4.7K 330 Resistor SMD:R 0805 2012Metric Resistor SMD:R 0805 2012Metric DS1337S+ Footprints:SOIC127P600X175-8N 24LC1025 ATMEGA328P- AU 32.768 KHz 16 MHz Package SO:SOIC-8 5.23x5.23mm P1. 27mm Footprints:QFP80P900X900X120-32N Crystal:Crystal SMD 5032-2Pin 5.0 x3.2mm HandSoldering Crystal:Crystal SMD 5032-2Pin 5.0 x3.2mm HandSoldering Table 11.1.1: The Bill of Materials for this project. I used Snapeda to ﬁnd the symbol-footprint pairs for U4. You should be able to ﬁnd all other symbols and footprints in KiCad’s libraries. In the next chapter, you will begin work on this project by creating a new KiCad project and Git repository. 11",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 166
  },
  {
    "text": " chapter, you will begin work on this project by creating a new KiCad project and Git repository. 112 1. Project - Introduction Welcome to Part 12 of this book. In the chapters that follow, you will design an ESP32 development board. To assist you with the design process, you will use the reference schematic design from Espressif, the original designer and manufacturer of the original ESP32 dev kit module. By working on this project, you will learn how to use and modify reference designs. The ESP32 is a widely used and understood board. It is compact, yet packs signiﬁcant computing power and capabilities. It’s circuit board is more complex compared to those in the previous projects of this book, but not to complex to make this project long and tedious. Below you can see the layout design a",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 167
  },
  {
    "text": "ook, but not to complex to make this project long and tedious. Below you can see the layout design as it will look once the project is completed. 113 Figure 13.1.1: The ESP32 development kit clone project deliverable. In this instance of the development kit, I have retained the form factor and shape of the original ESP32 development kit. This is a four-layer board, with the ESP32 module at the top with its integrated antenna extending outside of the board, the power and serial communications port at the bottom, and the pin headers along the sides. The board also features the two control buttons, “BOOT” and “EN”, and uses SMD components on the front and back. Here’s a view of the reference layout: 114 Figure 13.1.2: A view of the ESP32 development kit reference layout. Once you understand t",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 168
  },
  {
    "text": "yout: 114 Figure 13.1.2: A view of the ESP32 development kit reference layout. Once you understand the design elements of this board, you will be able to modify its shape and component placement to match the requirements of your project. For example, in my instance of the board, I have chosen to place the voltage regulator in the back of the PCB, even though in the reference design the regulator in is the front. I did this because I wanted to allow more room in the front for small components, like the resistors, to make assembly by hand easier. Below you can see the ﬁnal schematic. 115 Figure 13.1.3: The ESP32 development kit clone project schematic. Thanks to the ESP32 module’s highly integrated design, the board that hosts the module (i.e. the development kit) is relatively simply. In th",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 169
  },
  {
    "text": "rated design, the board that hosts the module (i.e. the development kit) is relatively simply. In the instance of the development kit design that you see above, I have arranged the components in ﬁve functional groups, and I have drawn all details from the original Espressif reference schematic design. You can see the reference schematic design below: Figure 13.1.4: The ESP32 development kit reference schematic. You will learn more about this in chapter 2. Below you can see the 3D rendering of the development kit. Figure 13.1.5: A 3D rendered view of the project deliverable. The 3D rendering contains models for all components and is accurate in terms of what the ﬁnal manufactured board would look like. The process of customising an existing board begins by ﬁnding the original schematic and ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 170
  },
  {
    "text": "look like. The process of customising an existing board begins by ﬁnding the original schematic and layout designs. In the case of the ESP32 development kit, you can ﬁnd the ofﬁcial reference designs in the Espressif website (https:// 116 www.espressif.com/en/support/documents/technical-documents). I have used the references design for the ESP32-DevKitC-v4 board. You can use the search ﬁlter to ﬁnd this design (or try my search URL ”https:// www.espressif.com/en/support/documents/technical-documents? keys=ESP32-Devkit”). Figure 13.1.6: The source documentation and designs for this project. Download the ZIP ﬁle that contains everything you will need for this project: the schematics, the PCB layout, and the BOM. The ZIP also contains a set of Gerber ﬁles which you do not need (you will gener",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 171
  },
  {
    "text": "ayout, and the BOM. The ZIP also contains a set of Gerber ﬁles which you do not need (you will generate a new set at the end of the project). The reference BOM is very important because it gives you all the components and their values that you will need for your custom board. These components and values are tested by Espressif and used in millions of manufactured board, so you can be conﬁdent that they will work. I used the reference BOM to help me select symbols and footprints for my instance of the board. The project BOM that you see below contains information that I sourced from the reference BOM. Refere Value Footprint nce C1, C2, C21 22uF/10V(20%) Capacitor SMD:C 0201 0603Metric 117 Q1, Q2 R2, R24 R7, R18 R11, R21, R22 R23 R25 R26 C9, C14, C19, C22 C15 C20 D1 D3 0.1uF/50V(10%) Capacit",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 172
  },
  {
    "text": " Q2 R2, R24 R7, R18 R11, R21, R22 R23 R25 R26 C9, C14, C19, C22 C15 C20 D1 D3 0.1uF/50V(10%) Capacitor SMD:C 01005 0402Metric 0.1uF/50V(10%) (NC) Capacitor SMD:C 01005 0402Metric 4.7uF/6.3V(10%) Capacitor SMD:C 01005 0402Metric LED LED SMD:LED 0603 1608Metric D Schottky Diode SMD:D SOD-323 D4, D5, D6 D TVS Diode SMD:D SOD-523 J1 USB B Micro J2, J3 Conn 01x19 Male MOD1 ESP32-WROOM-32 Connector USB:USB Micro- AB Molex 47590-0001 Connector PinHeader 2.54mm:PinHe ader 1x19 P2.54mm Vertical digikey-footprints:ESP32- WROOM-32D MMSS8050-H-TP digikey-footprints:SOT-23-3 2K(5%) 0R(5%) Resistor SMD:R 01005 0402Metric Resistor SMD:R 01005 0402Metric 10K(5%) Resistor SMD:R 01005 0402Metric 10K(5%)(NC) Resistor SMD:R 01005 0402Metric 22.1K(5%) 47.5K(5%) SW1, SW2 SW Push Resistor SMD:R 01005 0402Metric ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 173
  },
  {
    "text": "esistor SMD:R 01005 0402Metric 22.1K(5%) 47.5K(5%) SW1, SW2 SW Push Resistor SMD:R 01005 0402Metric Resistor SMD:R 01005 0402Metric Button Switch SMD:SW SPST B3S-1 000 U1 U2 CP2102N-A01- Package DFN QFN:TQFN-28-1EP 5x GQFN28 5mm P0.5mm EP2.7x2.7mm AMS1117-3.3 Package TO SOT SMD:SOT-223-3 Ta bPin2 Table 13.1.1: The Bill of Materials for this project. The BOM shows several SMD components that are very small, such as the 0402 resistors. If you plan to assemble your custom board by hand, you should consider the difﬁculty of working with such small components. But, since this is your custom board, you can choose to replace those small components with alternatives that you feel more comfortable to work with. 118 This is just an example of how you can modify a reference design to ﬁt your speciﬁc ",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 174
  },
  {
    "text": " work with. 118 This is just an example of how you can modify a reference design to ﬁt your speciﬁc requirements. The main objectives of this project are: 1. To help you practice skills you acquired in previous projects. 2. To gain experience in the design of a PCB based on an existing reference design. 3. To gain experience in creating dense, four-layer PCBs. I used Snapeda to ﬁnd the symbol-footprint pairs for MOD1 (the ESP32 module). You should be able to ﬁnd all other symbols and footprints in KiCad’s libraries. Let’s begin. 119",
    "source_file": "KiCadLikeaPro3e.pdf",
    "chunk_id": 175
  }
]